[
  {
    "id": "python-intro",
    "title": "Introduction to Python",
    "description": "Welcome to Python programming! Learn what Python is and why it's popular.",
    "category": "Basics",
    "difficulty": "beginner",
    "estimatedTime": 10,
    "xpReward": 30,
    "prerequisites": [],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "What is Python?",
        "content": "Python is a high-level, interpreted programming language created by Guido van Rossum in 1991. It's designed with readability in mind, using English keywords and simple syntax. Python is used in web development, data science, artificial intelligence, automation, and scientific computing."
      },
      {
        "id": "step-2",
        "type": "content",
        "title": "Why Choose Python?",
        "content": "• Easy to learn and read - Python's syntax is clean and intuitive\n• Versatile - Used in many fields from web apps to AI\n• Large community - Millions of developers worldwide\n• Rich libraries - Thousands of pre-built packages available\n• Cross-platform - Runs on Windows, Mac, Linux"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Your First Python Program",
        "content": "The traditional first program in any language prints 'Hello, World!' to the screen:",
        "code": "print('Hello, World!')\nprint('Welcome to Python programming!')\nprint('Python is', 2024 - 1991, 'years old')",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Personal Greeting",
        "description": "Create a program that prints a greeting with your name.",
        "starterCode": "# Print a greeting with your name\n",
        "expectedOutput": "Hello, my name is [Your Name]",
        "solution": "print('Hello, my name is Alice')"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium", 
        "title": "Python Facts",
        "description": "Print three interesting facts about Python using multiple print statements.",
        "starterCode": "# Print three facts about Python\n",
        "expectedOutput": "Fact 1: Python was named after Monty Python\nFact 2: Python is open source\nFact 3: Python is interpreted, not compiled",
        "solution": "print('Fact 1: Python was named after Monty Python')\nprint('Fact 2: Python is open source')\nprint('Fact 3: Python is interpreted, not compiled')"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Dynamic Information",
        "description": "Create a program that displays the current year and calculates Python's age dynamically.",
        "starterCode": "# Calculate and display Python's age\n# Python was created in 1991\n",
        "expectedOutput": "Current year: 2024\nPython's age: 33 years",
        "solution": "import datetime\ncurrent_year = datetime.datetime.now().year\npython_birth_year = 1991\nage = current_year - python_birth_year\nprint(f'Current year: {current_year}')\nprint(f'Python\\'s age: {age} years')"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "Who created the Python programming language?",
        "type": "multiple-choice",
        "options": ["Dennis Ritchie", "Guido van Rossum", "James Gosling", "Bjarne Stroustrup"],
        "correctAnswer": 1
      },
      {
        "id": "q2", 
        "question": "Python was first released in which year?",
        "type": "multiple-choice",
        "options": ["1989", "1991", "1995", "2000"],
        "correctAnswer": 1
      },
      {
        "id": "q3",
        "question": "Which function is used to display output in Python?",
        "type": "multiple-choice", 
        "options": ["output()", "display()", "print()", "show()"],
        "correctAnswer": 2
      }
    ]
  },
  {
    "id": "python-variables",
    "title": "Variables and Data Types",
    "description": "Learn to store and manipulate different types of data in Python.",
    "category": "Basics",
    "difficulty": "beginner",
    "estimatedTime": 15,
    "xpReward": 40,
    "prerequisites": ["python-intro"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Understanding Variables",
        "content": "A variable is a named storage location in memory that holds data. In Python, variables are created when you assign a value to them. Unlike other languages, you don't need to declare the variable type - Python automatically determines it based on the value assigned."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Creating Variables",
        "content": "Here's how to create variables of different types:",
        "code": "# String variable\nname = 'Alice'\nfull_name = \"Alice Johnson\"\n\n# Integer variable\nage = 25\nyear = 2024\n\n# Float variable\nheight = 5.6\ntemperature = 98.6\n\n# Boolean variable\nis_student = True\nhas_job = False\n\nprint(name, age, height, is_student)",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "content",
        "title": "Python Data Types",
        "content": "Python has several built-in data types:\n\n• str (String) - Text data: 'Hello'\n• int (Integer) - Whole numbers: 42\n• float - Decimal numbers: 3.14\n• bool (Boolean) - True or False\n• list - Ordered collection: [1, 2, 3]\n• dict (Dictionary) - Key-value pairs: {'key': 'value'}\n• tuple - Immutable sequence: (1, 2, 3)\n• set - Unique elements: {1, 2, 3}"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Checking Data Types",
        "content": "Use the type() function to check what type of data a variable contains:",
        "code": "name = 'Alice'\nage = 25\nheight = 5.6\nis_student = True\n\nprint(type(name))      # <class 'str'>\nprint(type(age))       # <class 'int'>\nprint(type(height))    # <class 'float'>\nprint(type(is_student)) # <class 'bool'>",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Personal Information",
        "description": "Create variables to store your name, age, and favorite color, then print them.",
        "starterCode": "# Create variables for personal information\n",
        "expectedOutput": "Name: Alice\nAge: 25\nFavorite Color: Blue",
        "solution": "name = 'Alice'\nage = 25\nfavorite_color = 'Blue'\n\nprint('Name:', name)\nprint('Age:', age)\nprint('Favorite Color:', favorite_color)"
      },
      {
        "id": "medium-1", 
        "difficulty": "Medium",
        "title": "Variable Operations", 
        "description": "Create numeric variables and perform basic calculations, storing results in new variables.",
        "starterCode": "# Create variables for a rectangle's dimensions\nlength = 10\nwidth = 5\n# Calculate area and perimeter\n",
        "expectedOutput": "Area: 50\nPerimeter: 30",
        "solution": "length = 10\nwidth = 5\narea = length * width\nperimeter = 2 * (length + width)\n\nprint('Area:', area)\nprint('Perimeter:', perimeter)"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Type Conversion Challenge",
        "description": "Create a program that takes string numbers, converts them to integers, performs calculations, and displays results.",
        "starterCode": "# String numbers that need conversion\nnum1_str = '15'\nnum2_str = '25'\n# Convert to integers and calculate\n",
        "expectedOutput": "Sum: 40\nProduct: 375\nAverage: 20.0",
        "solution": "num1_str = '15'\nnum2_str = '25'\n\nnum1 = int(num1_str)\nnum2 = int(num2_str)\n\nsum_result = num1 + num2\nproduct = num1 * num2\naverage = sum_result / 2\n\nprint('Sum:', sum_result)\nprint('Product:', product)\nprint('Average:', average)"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "Which of these is a valid variable name in Python?",
        "type": "multiple-choice",
        "options": ["2user", "user-name", "user_name", "user name"],
        "correctAnswer": 2
      },
      {
        "id": "q2",
        "question": "What data type is the value 3.14?",
        "type": "multiple-choice",
        "options": ["int", "float", "str", "bool"],
        "correctAnswer": 1
      },
      {
        "id": "q3",
        "question": "Which function tells you the data type of a variable?",
        "type": "multiple-choice",
        "options": ["typeof()", "type()", "datatype()", "kind()"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "python-dictionaries",
    "title": "Dictionaries and Key-Value Data",
    "description": "Master Python dictionaries for storing and accessing data with keys.",
    "category": "Data Structures",
    "difficulty": "intermediate",
    "estimatedTime": 30,
    "xpReward": 55,
    "prerequisites": ["python-variables"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Understanding Dictionaries",
        "content": "Dictionaries are collections of key-value pairs, similar to real-world dictionaries where words (keys) have definitions (values). They're unordered, mutable, and extremely useful for representing structured data like records, configurations, and mappings."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Creating and Accessing Dictionaries",
        "content": "Different ways to create and work with dictionaries:",
        "code": "# Creating dictionaries\nstudent = {\n    'name': 'Alice',\n    'age': 20,\n    'grade': 'A',\n    'enrolled': True\n}\n\n# Empty dictionary\nempty_dict = {}\n\n# Accessing values\nprint(student['name'])        # Alice\nprint(student.get('age'))     # 20\nprint(student.get('phone', 'Not provided'))  # Not provided\n\n# Check if key exists\nprint('grade' in student)     # True",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Modifying Dictionaries",
        "content": "Dictionaries are mutable - you can change them after creation:",
        "code": "# Starting dictionary\nproduct = {\n    'name': 'Laptop',\n    'price': 999.99,\n    'category': 'Electronics'\n}\n\n# Add new key-value pairs\nproduct['brand'] = 'TechCorp'\nproduct['in_stock'] = True\n\n# Update existing values\nproduct['price'] = 899.99\n\n# Remove items\ndel product['category']  # Remove with del\nremoved_stock = product.pop('in_stock')  # Remove and return value\n\nprint(product)\nprint(f'Stock status was: {removed_stock}')",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Dictionary Methods and Iteration",
        "content": "Useful methods for working with dictionaries:",
        "code": "# Sample data\ninventory = {\n    'apples': 50,\n    'bananas': 30,\n    'oranges': 25,\n    'grapes': 40\n}\n\n# Get all keys, values, and items\nprint('Fruits:', list(inventory.keys()))\nprint('Quantities:', list(inventory.values()))\nprint('All items:', list(inventory.items()))\n\n# Iterate through dictionary\nfor fruit, quantity in inventory.items():\n    print(f'{fruit}: {quantity} units')\n\n# Dictionary comprehension\nlow_stock = {fruit: qty for fruit, qty in inventory.items() if qty < 35}\nprint('Low stock:', low_stock)",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Student Record",
        "description": "Create a dictionary to store student information and display it.",
        "starterCode": "# Create a student record\nstudent_id = '12345'\nname = 'John Doe'\nage = 18\nmajor = 'Computer Science'\n",
        "expectedOutput": "Student Record:\nID: 12345\nName: John Doe\nAge: 18\nMajor: Computer Science",
        "solution": "student_id = '12345'\nname = 'John Doe'\nage = 18\nmajor = 'Computer Science'\n\nstudent = {\n    'id': student_id,\n    'name': name,\n    'age': age,\n    'major': major\n}\n\nprint('Student Record:')\nprint(f'ID: {student[\"id\"]}')\nprint(f'Name: {student[\"name\"]}')\nprint(f'Age: {student[\"age\"]}')\nprint(f'Major: {student[\"major\"]}')"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Inventory Manager",
        "description": "Create an inventory system that tracks products and their quantities.",
        "starterCode": "# Inventory management system\ninventory = {\n    'laptops': 15,\n    'mice': 50,\n    'keyboards': 23\n}\n# Add monitors: 8, update laptops to 12, remove mice\n",
        "expectedOutput": "Updated Inventory:\nlaptops: 12\nkeyboards: 23\nmonitors: 8\nRemoved mice: 50 units",
        "solution": "inventory = {\n    'laptops': 15,\n    'mice': 50,\n    'keyboards': 23\n}\n\n# Add monitors\ninventory['monitors'] = 8\n\n# Update laptops\ninventory['laptops'] = 12\n\n# Remove mice\nremoved_mice = inventory.pop('mice')\n\nprint('Updated Inventory:')\nfor item, quantity in inventory.items():\n    print(f'{item}: {quantity}')\nprint(f'Removed mice: {removed_mice} units')"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Grade Calculator System",
        "description": "Create a comprehensive grade management system with multiple students and subjects.",
        "starterCode": "# Grade management system\nstudents = {\n    'Alice': {'Math': 95, 'Science': 88, 'English': 92},\n    'Bob': {'Math': 78, 'Science': 85, 'English': 90},\n    'Carol': {'Math': 88, 'Science': 92, 'English': 85}\n}\n",
        "expectedOutput": "Grade Report:\nAlice - Average: 91.67 (A)\nBob - Average: 84.33 (B)\nCarol - Average: 88.33 (B)\n\nSubject Averages:\nMath: 87.0\nScience: 88.33\nEnglish: 89.0",
        "solution": "students = {\n    'Alice': {'Math': 95, 'Science': 88, 'English': 92},\n    'Bob': {'Math': 78, 'Science': 85, 'English': 90},\n    'Carol': {'Math': 88, 'Science': 92, 'English': 85}\n}\n\n# Calculate student averages\nprint('Grade Report:')\nfor student, grades in students.items():\n    average = sum(grades.values()) / len(grades)\n    if average >= 90:\n        letter_grade = 'A'\n    elif average >= 80:\n        letter_grade = 'B'\n    elif average >= 70:\n        letter_grade = 'C'\n    else:\n        letter_grade = 'F'\n    print(f'{student} - Average: {average:.2f} ({letter_grade})')\n\n# Calculate subject averages\nprint('\\nSubject Averages:')\nsubjects = ['Math', 'Science', 'English']\nfor subject in subjects:\n    total = sum(student_grades[subject] for student_grades in students.values())\n    average = total / len(students)\n    print(f'{subject}: {average:.2f}')"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "How do you access a value in a dictionary named 'data' with key 'name'?",
        "type": "multiple-choice",
        "options": ["data.name", "data['name']", "data(name)", "data->name"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "What method safely gets a value from a dictionary without causing an error if the key doesn't exist?",
        "type": "multiple-choice",
        "options": ["dict.safe()", "dict.get()", "dict.find()", "dict.check()"],
        "correctAnswer": 1
      },
      {
        "id": "q3",
        "question": "Which method returns all key-value pairs as tuples?",
        "type": "multiple-choice",
        "options": ["dict.keys()", "dict.values()", "dict.items()", "dict.pairs()"],
        "correctAnswer": 2
      }
    ]
  },
  {
    "id": "python-oop-basics",
    "title": "Object-Oriented Programming Basics",
    "description": "Learn to create classes and objects to organize and structure your code.",
    "category": "Object-Oriented Programming",
    "difficulty": "advanced",
    "estimatedTime": 45,
    "xpReward": 80,
    "prerequisites": ["python-dictionaries"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "What is Object-Oriented Programming?",
        "content": "Object-Oriented Programming (OOP) is a programming paradigm that organizes code around objects and classes. A class is a blueprint for creating objects, and objects are instances of classes. OOP helps create more maintainable, reusable, and organized code through encapsulation, inheritance, and polymorphism."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Creating Classes and Objects",
        "content": "Define classes with the 'class' keyword and create objects (instances):",
        "code": "# Define a simple class\nclass Person:\n    def __init__(self, name, age):\n        self.name = name  # Instance attribute\n        self.age = age\n    \n    def introduce(self):  # Instance method\n        return f'Hi, I am {self.name}, {self.age} years old'\n    \n    def have_birthday(self):\n        self.age += 1\n        return f'{self.name} is now {self.age} years old'\n\n# Create objects (instances)\nperson1 = Person('Alice', 25)\nperson2 = Person('Bob', 30)\n\nprint(person1.introduce())\nprint(person2.have_birthday())",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Class Attributes and Methods",
        "content": "Classes can have attributes and methods shared by all instances:",
        "code": "class BankAccount:\n    # Class attribute (shared by all instances)\n    bank_name = 'PyBank'\n    total_accounts = 0\n    \n    def __init__(self, owner, balance=0):\n        self.owner = owner  # Instance attribute\n        self.balance = balance\n        BankAccount.total_accounts += 1  # Update class attribute\n        self.account_number = BankAccount.total_accounts\n    \n    def deposit(self, amount):\n        if amount > 0:\n            self.balance += amount\n            return f'Deposited ${amount}. New balance: ${self.balance}'\n        return 'Invalid deposit amount'\n    \n    def withdraw(self, amount):\n        if 0 < amount <= self.balance:\n            self.balance -= amount\n            return f'Withdrew ${amount}. New balance: ${self.balance}'\n        return 'Insufficient funds or invalid amount'\n    \n    @classmethod\n    def get_total_accounts(cls):\n        return f'Total accounts: {cls.total_accounts}'\n\n# Create accounts\naccount1 = BankAccount('Alice', 1000)\naccount2 = BankAccount('Bob', 500)\n\nprint(account1.deposit(200))\nprint(BankAccount.get_total_accounts())",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Inheritance and Method Overriding",
        "content": "Create specialized classes that inherit from base classes:",
        "code": "# Base class\nclass Vehicle:\n    def __init__(self, brand, model, year):\n        self.brand = brand\n        self.model = model\n        self.year = year\n    \n    def start(self):\n        return f'{self.brand} {self.model} is starting...'\n    \n    def stop(self):\n        return f'{self.brand} {self.model} has stopped.'\n\n# Derived class (inherits from Vehicle)\nclass Car(Vehicle):\n    def __init__(self, brand, model, year, doors):\n        super().__init__(brand, model, year)  # Call parent constructor\n        self.doors = doors\n    \n    def honk(self):\n        return 'Beep beep!'\n    \n    # Override parent method\n    def start(self):\n        return f'{self.brand} {self.model} car is starting with a roar!'\n\nclass Motorcycle(Vehicle):\n    def __init__(self, brand, model, year, engine_size):\n        super().__init__(brand, model, year)\n        self.engine_size = engine_size\n    \n    def rev_engine(self):\n        return 'Vroom vroom!'\n\n# Create instances\nmy_car = Car('Toyota', 'Camry', 2022, 4)\nmy_bike = Motorcycle('Harley', 'Sportster', 2021, 883)\n\nprint(my_car.start())  # Uses overridden method\nprint(my_bike.start())  # Uses inherited method\nprint(my_car.honk())",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Rectangle Class",
        "description": "Create a Rectangle class with width, height, and methods to calculate area and perimeter.",
        "starterCode": "# Create Rectangle class\nclass Rectangle:\n    def __init__(self, width, height):\n        # Your code here\n        pass\n    \n    def area(self):\n        # Your code here\n        pass\n    \n    def perimeter(self):\n        # Your code here\n        pass\n\n# Test the class\nrect = Rectangle(5, 3)\n",
        "expectedOutput": "Area: 15\nPerimeter: 16",
        "solution": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n    \n    def area(self):\n        return self.width * self.height\n    \n    def perimeter(self):\n        return 2 * (self.width + self.height)\n\nrect = Rectangle(5, 3)\nprint(f'Area: {rect.area()}')\nprint(f'Perimeter: {rect.perimeter()}')"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Library Book System",
        "description": "Create a Book class and Library class to manage a collection of books.",
        "starterCode": "# Book and Library management system\nclass Book:\n    def __init__(self, title, author, isbn):\n        # Your code here\n        pass\n\nclass Library:\n    def __init__(self):\n        # Your code here\n        pass\n    \n    def add_book(self, book):\n        # Your code here\n        pass\n    \n    def find_book(self, title):\n        # Your code here\n        pass\n\n# Test the system\nlib = Library()\nbook1 = Book('1984', 'George Orwell', '123456789')\n",
        "expectedOutput": "Added: 1984 by George Orwell\nFound: 1984 by George Orwell (ISBN: 123456789)\nTotal books: 1",
        "solution": "class Book:\n    def __init__(self, title, author, isbn):\n        self.title = title\n        self.author = author\n        self.isbn = isbn\n    \n    def __str__(self):\n        return f'{self.title} by {self.author} (ISBN: {self.isbn})'\n\nclass Library:\n    def __init__(self):\n        self.books = []\n    \n    def add_book(self, book):\n        self.books.append(book)\n        return f'Added: {book.title} by {book.author}'\n    \n    def find_book(self, title):\n        for book in self.books:\n            if book.title.lower() == title.lower():\n                return f'Found: {book}'\n        return 'Book not found'\n    \n    def total_books(self):\n        return len(self.books)\n\nlib = Library()\nbook1 = Book('1984', 'George Orwell', '123456789')\nprint(lib.add_book(book1))\nprint(lib.find_book('1984'))\nprint(f'Total books: {lib.total_books()}')"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Employee Management System",
        "description": "Create an inheritance hierarchy with Employee base class and specialized Manager and Developer classes.",
        "starterCode": "# Employee management system with inheritance\nclass Employee:\n    def __init__(self, name, employee_id, salary):\n        # Your code here\n        pass\n\nclass Manager(Employee):\n    def __init__(self, name, employee_id, salary, department):\n        # Your code here\n        pass\n\nclass Developer(Employee):\n    def __init__(self, name, employee_id, salary, programming_language):\n        # Your code here\n        pass\n\n# Test the system\nmanager = Manager('Alice', 'M001', 75000, 'Engineering')\ndeveloper = Developer('Bob', 'D001', 65000, 'Python')\n",
        "expectedOutput": "Manager: Alice (M001) - $75000 - Engineering Department\nDeveloper: Bob (D001) - $65000 - Python Specialist\nAlice's annual bonus: $7500\nBob's coding skill: Expert in Python",
        "solution": "class Employee:\n    def __init__(self, name, employee_id, salary):\n        self.name = name\n        self.employee_id = employee_id\n        self.salary = salary\n    \n    def get_info(self):\n        return f'{self.name} ({self.employee_id}) - ${self.salary}'\n    \n    def calculate_bonus(self):\n        return self.salary * 0.05  # 5% bonus\n\nclass Manager(Employee):\n    def __init__(self, name, employee_id, salary, department):\n        super().__init__(name, employee_id, salary)\n        self.department = department\n    \n    def get_info(self):\n        return f'Manager: {super().get_info()} - {self.department} Department'\n    \n    def calculate_bonus(self):\n        return self.salary * 0.10  # 10% bonus for managers\n\nclass Developer(Employee):\n    def __init__(self, name, employee_id, salary, programming_language):\n        super().__init__(name, employee_id, salary)\n        self.programming_language = programming_language\n    \n    def get_info(self):\n        return f'Developer: {super().get_info()} - {self.programming_language} Specialist'\n    \n    def code_skill(self):\n        return f'Expert in {self.programming_language}'\n\nmanager = Manager('Alice', 'M001', 75000, 'Engineering')\ndeveloper = Developer('Bob', 'D001', 65000, 'Python')\n\nprint(manager.get_info())\nprint(developer.get_info())\nprint(f'{manager.name}\\'s annual bonus: ${manager.calculate_bonus():.0f}')\nprint(f'{developer.name}\\'s coding skill: {developer.code_skill()}')"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What method is automatically called when creating a new object?",
        "type": "multiple-choice",
        "options": ["__create__", "__init__", "__new__", "__start__"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "What keyword is used to inherit from a parent class?",
        "type": "multiple-choice",
        "options": ["extends", "inherits", "class ChildClass(ParentClass):", "implements"],
        "correctAnswer": 2
      },
      {
        "id": "q3",
        "question": "What is 'self' in Python class methods?",
        "type": "multiple-choice",
        "options": ["A keyword", "A reference to the current instance", "A built-in function", "A class attribute"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "python-loops",
    "title": "Loops and Iteration",
    "description": "Master for and while loops to repeat code efficiently and handle collections.",
    "category": "Control Flow",
    "difficulty": "intermediate",
    "estimatedTime": 25,
    "xpReward": 50,
    "prerequisites": ["python-variables"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Understanding Loops",
        "content": "Loops allow you to repeat code multiple times without writing it repeatedly. Python has two main types: 'for' loops (when you know how many times to repeat or iterate over collections) and 'while' loops (when you repeat until a condition changes). Loops are essential for processing data, automating tasks, and creating interactive programs."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "For Loops with Range and Collections",
        "content": "The most versatile way to repeat code:",
        "code": "# Basic for loop with range\nfor i in range(5):\n    print(f'Count: {i}')\n\n# Range with start, stop, step\nfor num in range(2, 11, 2):\n    print(f'Even: {num}')\n\n# Iterate over lists\nfruits = ['apple', 'banana', 'orange']\nfor fruit in fruits:\n    print(f'I like {fruit}')\n\n# Enumerate for index and value\nfor index, fruit in enumerate(fruits):\n    print(f'{index}: {fruit}')",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "While Loops and Loop Control",
        "content": "While loops and controlling loop execution:",
        "code": "# Basic while loop\ncount = 0\nwhile count < 5:\n    print(f'Count: {count}')\n    count += 1\n\n# Break - exit loop early\nfor i in range(10):\n    if i == 5:\n        break\n    print(i)\nprint('Loop ended early')\n\n# Continue - skip current iteration\nfor i in range(5):\n    if i == 2:\n        continue\n    print(f'Processing: {i}')\n\n# Nested loops\nfor row in range(3):\n    for col in range(3):\n        print(f'({row},{col})', end=' ')\n    print()  # New line after each row",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Sum Calculator",
        "description": "Use a loop to calculate the sum of numbers from 1 to 10.",
        "starterCode": "# Calculate sum of numbers 1 to 10\ntotal = 0\n",
        "expectedOutput": "Sum of 1 to 10: 55",
        "solution": "total = 0\nfor i in range(1, 11):\n    total += i\nprint(f'Sum of 1 to 10: {total}')"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Password Validator Loop",
        "description": "Keep asking for a password until it meets requirements (at least 8 characters).",
        "starterCode": "# Password validation loop\npasswords = ['123', 'short', 'validpassword123']\npassword_index = 0\n",
        "expectedOutput": "Password too short, try again.\nPassword too short, try again.\nPassword accepted!",
        "solution": "passwords = ['123', 'short', 'validpassword123']\npassword_index = 0\n\nwhile password_index < len(passwords):\n    password = passwords[password_index]\n    if len(password) >= 8:\n        print('Password accepted!')\n        break\n    else:\n        print('Password too short, try again.')\n    password_index += 1"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Pattern Generator",
        "description": "Create a program that generates number patterns using nested loops.",
        "starterCode": "# Generate number patterns\nrows = 4\n",
        "expectedOutput": "1\n1 2\n1 2 3\n1 2 3 4",
        "solution": "rows = 4\n\nfor i in range(1, rows + 1):\n    for j in range(1, i + 1):\n        print(j, end=' ')\n    print()  # New line after each row"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What does range(1, 6) generate?",
        "type": "multiple-choice",
        "options": ["[1, 2, 3, 4, 5, 6]", "[1, 2, 3, 4, 5]", "[0, 1, 2, 3, 4, 5]", "[2, 3, 4, 5, 6]"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "What does the 'break' statement do?",
        "type": "multiple-choice",
        "options": ["Skips current iteration", "Exits the loop completely", "Pauses the loop", "Restarts the loop"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "python-functions",
    "title": "Functions and Code Organization",
    "description": "Create reusable code blocks with functions, parameters, and return values.",
    "category": "Functions",
    "difficulty": "intermediate",
    "estimatedTime": 35,
    "xpReward": 65,
    "prerequisites": ["python-loops"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Why Functions Matter",
        "content": "Functions are the building blocks of organized, maintainable code. They allow you to break complex problems into smaller, manageable pieces, avoid code repetition, and create reusable components. Functions make your code more readable, testable, and easier to debug."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Creating and Calling Functions",
        "content": "Basic function syntax and usage:",
        "code": "# Simple function\ndef greet():\n    print('Hello, World!')\n\n# Function with parameters\ndef greet_person(name, age=25):\n    return f'Hello {name}, you are {age} years old'\n\n# Function with multiple return values\ndef calculate_stats(numbers):\n    total = sum(numbers)\n    average = total / len(numbers)\n    return total, average\n\n# Call functions\ngreet()\nmessage = greet_person('Alice')\nprint(message)\n\ntotal, avg = calculate_stats([1, 2, 3, 4, 5])\nprint(f'Total: {total}, Average: {avg}')",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Advanced Function Features",
        "content": "Variable arguments, keyword arguments, and lambda functions:",
        "code": "# Variable arguments\ndef sum_all(*numbers):\n    return sum(numbers)\n\n# Keyword arguments\ndef create_profile(**kwargs):\n    profile = {}\n    for key, value in kwargs.items():\n        profile[key] = value\n    return profile\n\n# Lambda functions (anonymous functions)\nsquare = lambda x: x ** 2\nnumbers = [1, 2, 3, 4, 5]\nsquared = list(map(square, numbers))\n\n# Function as argument\ndef apply_operation(numbers, operation):\n    return [operation(x) for x in numbers]\n\nprint(sum_all(1, 2, 3, 4, 5))\nprint(create_profile(name='Alice', age=25, city='NYC'))\nprint(squared)\nprint(apply_operation([1, 2, 3], lambda x: x * 2))",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Temperature Converter",
        "description": "Create functions to convert between Celsius and Fahrenheit.",
        "starterCode": "# Temperature conversion functions\ndef celsius_to_fahrenheit(celsius):\n    # Your code here\n    pass\n\ndef fahrenheit_to_celsius(fahrenheit):\n    # Your code here\n    pass\n\n# Test\ntemp_c = 25\ntemp_f = 77\n",
        "expectedOutput": "25°C = 77.0°F\n77°F = 25.0°C",
        "solution": "def celsius_to_fahrenheit(celsius):\n    return (celsius * 9/5) + 32\n\ndef fahrenheit_to_celsius(fahrenheit):\n    return (fahrenheit - 32) * 5/9\n\ntemp_c = 25\ntemp_f = 77\n\nprint(f'{temp_c}°C = {celsius_to_fahrenheit(temp_c)}°F')\nprint(f'{temp_f}°F = {fahrenheit_to_celsius(temp_f)}°C')"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Grade Calculator",
        "description": "Create a function that calculates letter grades with multiple scoring criteria.",
        "starterCode": "# Grade calculation system\ndef calculate_grade(homework, quizzes, midterm, final):\n    # Weights: homework 25%, quizzes 25%, midterm 25%, final 25%\n    pass\n\ndef get_letter_grade(percentage):\n    # A: 90+, B: 80-89, C: 70-79, D: 60-69, F: <60\n    pass\n\n# Test\nstudent_scores = (85, 90, 78, 92)\n",
        "expectedOutput": "Final Grade: 86.25%\nLetter Grade: B",
        "solution": "def calculate_grade(homework, quizzes, midterm, final):\n    weights = [0.25, 0.25, 0.25, 0.25]\n    scores = [homework, quizzes, midterm, final]\n    total = sum(score * weight for score, weight in zip(scores, weights))\n    return total\n\ndef get_letter_grade(percentage):\n    if percentage >= 90:\n        return 'A'\n    elif percentage >= 80:\n        return 'B'\n    elif percentage >= 70:\n        return 'C'\n    elif percentage >= 60:\n        return 'D'\n    else:\n        return 'F'\n\nstudent_scores = (85, 90, 78, 92)\nfinal_grade = calculate_grade(*student_scores)\nletter = get_letter_grade(final_grade)\n\nprint(f'Final Grade: {final_grade}%')\nprint(f'Letter Grade: {letter}')"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What keyword defines a function in Python?",
        "type": "multiple-choice",
        "options": ["function", "def", "define", "func"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "What does *args allow in a function?",
        "type": "multiple-choice",
        "options": ["Multiple keyword arguments", "Variable number of positional arguments", "Default arguments", "Return multiple values"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "python-file-handling",
    "title": "File Input and Output",
    "description": "Learn to read from and write to files for data persistence and processing.",
    "category": "File Operations",
    "difficulty": "advanced",
    "estimatedTime": 40,
    "xpReward": 70,
    "prerequisites": ["python-functions"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Why File Handling Matters",
        "content": "File handling allows your programs to persist data beyond program execution, process large datasets, create logs, read configuration files, and interact with external data sources. It's essential for building real-world applications that need to store and retrieve information."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Reading and Writing Files",
        "content": "Basic file operations using context managers:",
        "code": "# Writing to a file\nwith open('example.txt', 'w') as file:\n    file.write('Hello, World!\\n')\n    file.write('This is a Python file handling example.\\n')\n    file.writelines(['Line 3\\n', 'Line 4\\n'])\n\n# Reading from a file\nwith open('example.txt', 'r') as file:\n    content = file.read()\n    print('Full content:')\n    print(content)\n\n# Reading line by line\nwith open('example.txt', 'r') as file:\n    print('Line by line:')\n    for line_number, line in enumerate(file, 1):\n        print(f'{line_number}: {line.strip()}')",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Working with CSV and JSON Files",
        "content": "Handle structured data formats:",
        "code": "import json\nimport csv\nfrom io import StringIO\n\n# Working with JSON\ndata = {\n    'students': [\n        {'name': 'Alice', 'grade': 85},\n        {'name': 'Bob', 'grade': 92}\n    ]\n}\n\n# Write JSON\nwith open('students.json', 'w') as file:\n    json.dump(data, file, indent=2)\n\n# Read JSON\nwith open('students.json', 'r') as file:\n    loaded_data = json.load(file)\n    print('JSON data:', loaded_data)\n\n# Working with CSV (simulated)\ncsv_content = 'name,age,city\\nAlice,25,NYC\\nBob,30,LA'\ncsv_file = StringIO(csv_content)\n\nreader = csv.DictReader(csv_file)\nprint('CSV data:')\nfor row in reader:\n    print(f'{row[\"name\"]} is {row[\"age\"]} years old from {row[\"city\"]}')",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Simple Log Writer",
        "description": "Create a function that writes log messages to a file with timestamps.",
        "starterCode": "# Log writing function\nimport datetime\n\ndef write_log(message, log_file='app.log'):\n    # Your code here\n    pass\n\n# Test\nwrite_log('Application started')\nwrite_log('User logged in')\n",
        "expectedOutput": "Log written to app.log\nLog written to app.log",
        "solution": "import datetime\n\ndef write_log(message, log_file='app.log'):\n    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n    log_entry = f'{timestamp} - {message}\\n'\n    \n    with open(log_file, 'a') as file:\n        file.write(log_entry)\n    \n    return f'Log written to {log_file}'\n\nprint(write_log('Application started'))\nprint(write_log('User logged in'))"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Student Grade Manager",
        "description": "Create a system to save and load student grades from a JSON file.",
        "starterCode": "# Student grade management\nimport json\n\ndef save_grades(students, filename='grades.json'):\n    # Your code here\n    pass\n\ndef load_grades(filename='grades.json'):\n    # Your code here\n    pass\n\n# Test data\nstudents = {\n    'Alice': {'math': 85, 'science': 92},\n    'Bob': {'math': 78, 'science': 88}\n}\n",
        "expectedOutput": "Grades saved successfully\nLoaded grades: {'Alice': {'math': 85, 'science': 92}, 'Bob': {'math': 78, 'science': 88}}",
        "solution": "import json\n\ndef save_grades(students, filename='grades.json'):\n    try:\n        with open(filename, 'w') as file:\n            json.dump(students, file, indent=2)\n        return 'Grades saved successfully'\n    except Exception as e:\n        return f'Error saving grades: {e}'\n\ndef load_grades(filename='grades.json'):\n    try:\n        with open(filename, 'r') as file:\n            return json.load(file)\n    except FileNotFoundError:\n        return {}\n    except Exception as e:\n        return f'Error loading grades: {e}'\n\nstudents = {\n    'Alice': {'math': 85, 'science': 92},\n    'Bob': {'math': 78, 'science': 88}\n}\n\nprint(save_grades(students))\nloaded = load_grades()\nprint(f'Loaded grades: {loaded}')"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What is the recommended way to open files in Python?",
        "type": "multiple-choice",
        "options": ["open('file.txt')", "with open('file.txt') as f:", "file = open('file.txt')", "File.open('file.txt')"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which mode opens a file for writing (overwrites existing content)?",
        "type": "multiple-choice",
        "options": ["'r'", "'w'", "'a'", "'x'"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "python-error-handling",
    "title": "Exception Handling and Debugging",
    "description": "Learn to handle errors gracefully and debug your Python programs effectively.",
    "category": "Error Handling",
    "difficulty": "advanced",
    "estimatedTime": 35,
    "xpReward": 75,
    "prerequisites": ["python-file-handling"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Understanding Exceptions",
        "content": "Exceptions are events that occur during program execution that disrupt normal flow. Python uses try-except blocks to handle exceptions gracefully, preventing crashes and providing meaningful error messages to users. Good exception handling makes your programs robust and user-friendly."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Basic Exception Handling",
        "content": "Using try-except blocks to handle errors:",
        "code": "# Basic exception handling\ntry:\n    number = int(input('Enter a number: '))\n    result = 10 / number\n    print(f'Result: {result}')\nexcept ValueError:\n    print('Invalid input! Please enter a valid number.')\nexcept ZeroDivisionError:\n    print('Cannot divide by zero!')\nexcept Exception as e:\n    print(f'An unexpected error occurred: {e}')\nelse:\n    print('Operation completed successfully!')\nfinally:\n    print('This always executes.')\n\n# Multiple exceptions in one block\ntry:\n    data = {'name': 'Alice'}\n    print(data['age'])  # KeyError\nexcept (KeyError, ValueError, TypeError) as e:\n    print(f'Error accessing data: {e}')",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Custom Exceptions and Advanced Handling",
        "content": "Creating custom exceptions and advanced error handling patterns:",
        "code": "# Custom exception classes\nclass ValidationError(Exception):\n    def __init__(self, message, error_code=None):\n        super().__init__(message)\n        self.error_code = error_code\n\nclass PasswordTooShortError(ValidationError):\n    pass\n\ndef validate_password(password):\n    if len(password) < 8:\n        raise PasswordTooShortError('Password must be at least 8 characters', 'PWD_001')\n    if not any(c.isupper() for c in password):\n        raise ValidationError('Password must contain uppercase letter', 'PWD_002')\n    return True\n\n# Using custom exceptions\npasswords = ['weak', 'NOUPPERCASE', 'ValidPass123']\n\nfor pwd in passwords:\n    try:\n        validate_password(pwd)\n        print(f'Password \"{pwd}\" is valid')\n    except PasswordTooShortError as e:\n        print(f'Short password error: {e} (Code: {e.error_code})')\n    except ValidationError as e:\n        print(f'Validation error: {e} (Code: {e.error_code})')",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Safe Calculator",
        "description": "Create a calculator function that handles division by zero and invalid inputs.",
        "starterCode": "# Safe calculator function\ndef safe_divide(a, b):\n    # Your code here\n    pass\n\n# Test cases\ntest_cases = [(10, 2), (10, 0), ('abc', 5), (10, 'def')]\n",
        "expectedOutput": "10 / 2 = 5.0\nError: Cannot divide by zero\nError: Invalid input type\nError: Invalid input type",
        "solution": "def safe_divide(a, b):\n    try:\n        result = a / b\n        return f'{a} / {b} = {result}'\n    except ZeroDivisionError:\n        return 'Error: Cannot divide by zero'\n    except TypeError:\n        return 'Error: Invalid input type'\n    except Exception as e:\n        return f'Error: {e}'\n\ntest_cases = [(10, 2), (10, 0), ('abc', 5), (10, 'def')]\n\nfor a, b in test_cases:\n    print(safe_divide(a, b))"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "File Reader with Error Handling",
        "description": "Create a robust file reading function that handles various file-related errors.",
        "starterCode": "# Robust file reader\ndef read_file_safely(filename):\n    # Handle FileNotFoundError, PermissionError, etc.\n    pass\n\n# Test files\nfiles = ['existing.txt', 'nonexistent.txt', '/restricted/file.txt']\n",
        "expectedOutput": "Successfully read existing.txt\nError: File 'nonexistent.txt' not found\nError: Permission denied for '/restricted/file.txt'",
        "solution": "def read_file_safely(filename):\n    try:\n        with open(filename, 'r') as file:\n            content = file.read()\n            return f'Successfully read {filename}'\n    except FileNotFoundError:\n        return f'Error: File \\'{filename}\\' not found'\n    except PermissionError:\n        return f'Error: Permission denied for \\'{filename}\\''\n    except IsADirectoryError:\n        return f'Error: \\'{filename}\\' is a directory, not a file'\n    except Exception as e:\n        return f'Error reading \\'{filename}\\': {e}'\n\nfiles = ['existing.txt', 'nonexistent.txt', '/restricted/file.txt']\n\n# Create a test file first\ntry:\n    with open('existing.txt', 'w') as f:\n        f.write('Test content')\nexcept:\n    pass\n\nfor filename in files:\n    print(read_file_safely(filename))"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "Which keyword is used to handle exceptions in Python?",
        "type": "multiple-choice",
        "options": ["catch", "except", "handle", "error"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "What block always executes regardless of whether an exception occurs?",
        "type": "multiple-choice",
        "options": ["else", "except", "finally", "always"],
        "correctAnswer": 2
      }
    ]
  },
  {
    "id": "python-modules",
    "title": "Modules and Packages",
    "description": "Organize code with modules, import libraries, and create reusable packages.",
    "category": "Code Organization",
    "difficulty": "advanced",
    "estimatedTime": 30,
    "xpReward": 65,
    "prerequisites": ["python-error-handling"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Understanding Modules",
        "content": "Modules are Python files containing definitions and statements that can be imported and used in other programs. They help organize code, avoid naming conflicts, and promote code reuse. Python has a rich standard library of built-in modules, and you can also create your own modules."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Importing and Using Modules",
        "content": "Different ways to import and use modules:",
        "code": "# Standard library modules\nimport math\nimport datetime\nimport random\nfrom collections import Counter, defaultdict\nimport os\n\n# Using imported modules\nprint(f'Pi: {math.pi}')\nprint(f'Square root of 16: {math.sqrt(16)}')\n\n# Current date and time\nnow = datetime.datetime.now()\nprint(f'Current time: {now.strftime(\"%Y-%m-%d %H:%M:%S\")}')\n\n# Random numbers\nprint(f'Random number: {random.randint(1, 100)}')\nprint(f'Random choice: {random.choice([\"apple\", \"banana\", \"cherry\"])}')\n\n# Collections\nwords = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']\nword_count = Counter(words)\nprint(f'Word frequency: {word_count}')\n\n# Environment and system\nprint(f'Current directory: {os.getcwd()}')\nprint(f'Environment PATH: {os.environ.get(\"PATH\", \"Not found\")[:50]}...')",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Creating Custom Modules",
        "content": "How to create and organize your own modules:",
        "code": "# Example of a custom module (math_utils.py)\n# This would typically be in a separate file\n\ndef calculate_area(shape, **kwargs):\n    \"\"\"Calculate area of different shapes.\"\"\"\n    if shape == 'rectangle':\n        return kwargs['length'] * kwargs['width']\n    elif shape == 'circle':\n        import math\n        return math.pi * kwargs['radius'] ** 2\n    elif shape == 'triangle':\n        return 0.5 * kwargs['base'] * kwargs['height']\n    else:\n        raise ValueError(f'Unknown shape: {shape}')\n\ndef factorial(n):\n    \"\"\"Calculate factorial of n.\"\"\"\n    if n < 0:\n        raise ValueError('Factorial not defined for negative numbers')\n    if n == 0 or n == 1:\n        return 1\n    return n * factorial(n - 1)\n\nclass Calculator:\n    \"\"\"Simple calculator class.\"\"\"\n    \n    def __init__(self):\n        self.history = []\n    \n    def add(self, a, b):\n        result = a + b\n        self.history.append(f'{a} + {b} = {result}')\n        return result\n    \n    def get_history(self):\n        return self.history\n\n# If this were imported, you could use:\n# from math_utils import calculate_area, Calculator\n# Or: import math_utils\n\n# Demonstrating usage\nprint(f'Rectangle area: {calculate_area(\"rectangle\", length=5, width=3)}')\nprint(f'Circle area: {calculate_area(\"circle\", radius=2):.2f}')\nprint(f'Factorial of 5: {factorial(5)}')\n\ncalc = Calculator()\nprint(f'5 + 3 = {calc.add(5, 3)}')\nprint(f'History: {calc.get_history()}')",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Date and Time Utilities",
        "description": "Use the datetime module to create date formatting functions.",
        "starterCode": "# Date and time utilities\nimport datetime\n\ndef format_date(date_obj):\n    # Format as 'January 15, 2024'\n    pass\n\ndef days_until_birthday(birthday_str):\n    # Calculate days until next birthday\n    # birthday_str format: 'MM-DD' (e.g., '03-15')\n    pass\n\n# Test\ntoday = datetime.date.today()\nbirthday = '03-15'\n",
        "expectedOutput": "Today: January 15, 2024\nDays until birthday: 59",
        "solution": "import datetime\n\ndef format_date(date_obj):\n    return date_obj.strftime('%B %d, %Y')\n\ndef days_until_birthday(birthday_str):\n    today = datetime.date.today()\n    month, day = map(int, birthday_str.split('-'))\n    \n    # This year's birthday\n    this_year_birthday = datetime.date(today.year, month, day)\n    \n    # If birthday has passed this year, calculate for next year\n    if this_year_birthday < today:\n        next_birthday = datetime.date(today.year + 1, month, day)\n    else:\n        next_birthday = this_year_birthday\n    \n    delta = next_birthday - today\n    return delta.days\n\ntoday = datetime.date.today()\nbirthday = '03-15'\n\nprint(f'Today: {format_date(today)}')\nprint(f'Days until birthday: {days_until_birthday(birthday)}')"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Statistics Module",
        "description": "Create a statistics module with functions for mean, median, and mode.",
        "starterCode": "# Statistics module functions\nfrom collections import Counter\n\ndef calculate_mean(numbers):\n    # Calculate arithmetic mean\n    pass\n\ndef calculate_median(numbers):\n    # Calculate median value\n    pass\n\ndef calculate_mode(numbers):\n    # Calculate mode (most frequent value)\n    pass\n\ndef get_statistics(numbers):\n    # Return all statistics as a dictionary\n    pass\n\n# Test data\ndata = [1, 2, 2, 3, 4, 4, 4, 5]\n",
        "expectedOutput": "Statistics for [1, 2, 2, 3, 4, 4, 4, 5]:\nMean: 3.125\nMedian: 3.5\nMode: 4\nFull stats: {'mean': 3.125, 'median': 3.5, 'mode': 4, 'count': 8}",
        "solution": "from collections import Counter\n\ndef calculate_mean(numbers):\n    return sum(numbers) / len(numbers)\n\ndef calculate_median(numbers):\n    sorted_nums = sorted(numbers)\n    n = len(sorted_nums)\n    if n % 2 == 0:\n        return (sorted_nums[n//2 - 1] + sorted_nums[n//2]) / 2\n    else:\n        return sorted_nums[n//2]\n\ndef calculate_mode(numbers):\n    counter = Counter(numbers)\n    max_count = max(counter.values())\n    modes = [num for num, count in counter.items() if count == max_count]\n    return modes[0] if len(modes) == 1 else modes\n\ndef get_statistics(numbers):\n    return {\n        'mean': calculate_mean(numbers),\n        'median': calculate_median(numbers),\n        'mode': calculate_mode(numbers),\n        'count': len(numbers)\n    }\n\ndata = [1, 2, 2, 3, 4, 4, 4, 5]\n\nprint(f'Statistics for {data}:')\nprint(f'Mean: {calculate_mean(data)}')\nprint(f'Median: {calculate_median(data)}')\nprint(f'Mode: {calculate_mode(data)}')\nprint(f'Full stats: {get_statistics(data)}')"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "How do you import only specific functions from a module?",
        "type": "multiple-choice",
        "options": ["import module.function", "from module import function", "import function from module", "module.import(function)"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "What is the purpose of the __name__ == '__main__' check?",
        "type": "multiple-choice",
        "options": ["To check if the file is being run directly", "To import modules", "To define functions", "To handle errors"],
        "correctAnswer": 0
      }
    ]
  },
  {
    "id": "algorithms-intro",
    "title": "Introduction to Algorithms",
    "description": "Learn fundamental algorithms and computational thinking principles.",
    "category": "Algorithms",
    "difficulty": "advanced",
    "estimatedTime": 25,
    "xpReward": 100,
    "prerequisites": ["python-functions", "python-loops", "python-conditionals"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "What are Algorithms?",
        "content": "An algorithm is a step-by-step procedure for solving a problem or completing a task. In programming, algorithms are the logical foundations that enable computers to process data efficiently. Think of an algorithm as a recipe - it provides clear instructions to achieve a desired outcome.\n\nKey characteristics of good algorithms:\n• Clear and unambiguous steps\n• Finite - they must eventually terminate\n• Effective - each step must be achievable\n• Input and output defined\n• Efficient - uses resources optimally"
      },
      {
        "id": "step-2",
        "type": "content",
        "title": "Algorithm Complexity",
        "content": "Algorithm complexity measures how efficiently an algorithm uses time and space as input size grows:\n\n• Time Complexity: How execution time increases with input size\n• Space Complexity: How memory usage increases with input size\n\nCommon complexity notations:\n• O(1) - Constant time\n• O(log n) - Logarithmic time\n• O(n) - Linear time\n• O(n²) - Quadratic time\n• O(2ⁿ) - Exponential time"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Linear Search Algorithm",
        "content": "Linear search checks each element sequentially until finding the target:",
        "code": "def linear_search(arr, target):\n    \"\"\"\n    Search for target in array using linear search\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    for i in range(len(arr)):\n        if arr[i] == target:\n            return i  # Return index if found\n    return -1  # Return -1 if not found\n\n# Example usage\nnumbers = [3, 7, 1, 9, 4, 6, 2]\ntarget = 9\n\nresult = linear_search(numbers, target)\nif result != -1:\n    print(f\"Found {target} at index {result}\")\nelse:\n    print(f\"{target} not found in the array\")",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Binary Search Algorithm",
        "content": "Binary search works on sorted arrays by repeatedly dividing the search space:",
        "code": "def binary_search(arr, target):\n    \"\"\"\n    Search for target in sorted array using binary search\n    Time Complexity: O(log n)\n    Space Complexity: O(1)\n    \"\"\"\n    left, right = 0, len(arr) - 1\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    \n    return -1\n\n# Example usage\nsorted_numbers = [1, 2, 3, 4, 6, 7, 9]\ntarget = 6\n\nresult = binary_search(sorted_numbers, target)\nprint(f\"Binary search result: {result}\")\n\n# Compare with linear search\nprint(f\"Linear search result: {linear_search(sorted_numbers, target)}\")",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Find Maximum",
        "description": "Write a function to find the maximum element in a list.",
        "starterCode": "def find_maximum(numbers):\n    # Write your algorithm here\n    pass\n\n# Test your function\ntest_list = [3, 7, 1, 9, 4, 6, 2]\nprint(find_maximum(test_list))",
        "expectedOutput": "9",
        "solution": "def find_maximum(numbers):\n    if not numbers:\n        return None\n    \n    max_val = numbers[0]\n    for num in numbers[1:]:\n        if num > max_val:\n            max_val = num\n    return max_val"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Bubble Sort",
        "description": "Implement the bubble sort algorithm to sort a list in ascending order.",
        "starterCode": "def bubble_sort(arr):\n    # Implement bubble sort algorithm\n    pass\n\n# Test your function\ntest_array = [64, 34, 25, 12, 22, 11, 90]\nbubble_sort(test_array)\nprint(test_array)",
        "expectedOutput": "[11, 12, 22, 25, 34, 64, 90]",
        "solution": "def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n - i - 1):\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Fibonacci with Memoization",
        "description": "Implement an efficient Fibonacci function using memoization to avoid redundant calculations.",
        "starterCode": "def fibonacci_memo(n, memo={}):\n    # Implement memoized Fibonacci\n    pass\n\n# Test your function\nfor i in range(10):\n    print(f\"F({i}) = {fibonacci_memo(i)}\")",
        "expectedOutput": "F(0) = 0\nF(1) = 1\nF(2) = 1\nF(3) = 2\nF(4) = 3\nF(5) = 5\nF(6) = 8\nF(7) = 13\nF(8) = 21\nF(9) = 34",
        "solution": "def fibonacci_memo(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 1:\n        return n\n    memo[n] = fibonacci_memo(n-1, memo) + fibonacci_memo(n-2, memo)\n    return memo[n]"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What is the time complexity of binary search?",
        "type": "multiple-choice",
        "options": ["O(n)", "O(log n)", "O(n²)", "O(1)"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which search algorithm requires the array to be sorted?",
        "type": "multiple-choice",
        "options": ["Linear search", "Binary search", "Both", "Neither"],
        "correctAnswer": 1
      },
      {
        "id": "q3",
        "question": "What does O(1) complexity mean?",
        "type": "multiple-choice",
        "options": ["Takes 1 second", "Executes once", "Constant time regardless of input size", "Linear time"],
        "correctAnswer": 2
      }
    ]
  },
  {
    "id": "web-scraping-intro",
    "title": "Web Scraping Fundamentals",
    "description": "Learn to extract data from websites using Python's powerful scraping libraries.",
    "category": "Web Scraping",
    "difficulty": "advanced",
    "estimatedTime": 30,
    "xpReward": 120,
    "prerequisites": ["python-functions", "python-dictionaries", "python-modules"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "What is Web Scraping?",
        "content": "Web scraping is the process of automatically extracting data from websites. It involves sending HTTP requests to web pages and parsing the HTML content to extract specific information.\n\nCommon use cases:\n• Price monitoring for e-commerce\n• Social media sentiment analysis\n• Research data collection\n• News aggregation\n• Real estate listings\n• Job market analysis\n\nEthical considerations:\n• Respect robots.txt files\n• Don't overload servers with requests\n• Check website terms of service\n• Use rate limiting between requests"
      },
      {
        "id": "step-2",
        "type": "content",
        "title": "Essential Libraries",
        "content": "Python provides powerful libraries for web scraping:\n\n• requests: Make HTTP requests to websites\n• BeautifulSoup: Parse and navigate HTML/XML documents\n• selenium: Automate web browsers for dynamic content\n• scrapy: Full-featured scraping framework\n• pandas: Data manipulation and analysis\n• time: Add delays between requests\n\nNote: In this learning environment, we'll simulate web scraping concepts since we can't install external libraries, but the principles remain the same."
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "HTML Parsing Simulation",
        "content": "Let's simulate parsing HTML content (normally you'd use BeautifulSoup):",
        "code": "# Simulated HTML content (normally from requests.get())\nhtml_content = \"\"\"\n<html>\n<head><title>Sample News Site</title></head>\n<body>\n    <div class=\"article\">\n        <h2>Python Becomes Most Popular Language</h2>\n        <p class=\"author\">By Alice Johnson</p>\n        <p class=\"content\">Python continues to dominate programming surveys...</p>\n        <span class=\"date\">2024-01-15</span>\n    </div>\n    <div class=\"article\">\n        <h2>AI Revolution in Education</h2>\n        <p class=\"author\">By Bob Smith</p>\n        <p class=\"content\">Artificial intelligence is transforming learning...</p>\n        <span class=\"date\">2024-01-14</span>\n    </div>\n</body>\n</html>\n\"\"\"\n\n# Simple HTML parsing function\ndef extract_articles(html):\n    articles = []\n    # Simulate finding article sections\n    lines = html.split('\\n')\n    current_article = {}\n    \n    for line in lines:\n        line = line.strip()\n        if '<h2>' in line:\n            title = line.replace('<h2>', '').replace('</h2>', '')\n            current_article['title'] = title\n        elif 'class=\"author\"' in line:\n            author = line.split('>')[1].split('<')[0]\n            current_article['author'] = author\n        elif 'class=\"date\"' in line:\n            date = line.split('>')[1].split('<')[0]\n            current_article['date'] = date\n            articles.append(current_article.copy())\n            current_article = {}\n    \n    return articles\n\n# Extract and display articles\narticles = extract_articles(html_content)\nfor i, article in enumerate(articles, 1):\n    print(f\"Article {i}:\")\n    print(f\"  Title: {article['title']}\")\n    print(f\"  Author: {article['author']}\")\n    print(f\"  Date: {article['date']}\")\n    print()",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Data Processing and Storage",
        "content": "After scraping, you typically need to clean and store the data:",
        "code": "import json\nfrom datetime import datetime\n\n# Sample scraped data\nscraped_data = [\n    {'title': 'Python Becomes Most Popular Language', 'author': 'Alice Johnson', 'date': '2024-01-15'},\n    {'title': 'AI Revolution in Education', 'author': 'Bob Smith', 'date': '2024-01-14'},\n    {'title': 'Machine Learning Trends', 'author': 'Carol Wilson', 'date': '2024-01-13'}\n]\n\ndef clean_and_process_data(articles):\n    cleaned_articles = []\n    \n    for article in articles:\n        # Clean title (remove extra spaces, convert to title case)\n        clean_title = article['title'].strip().title()\n        \n        # Extract just the name from author\n        clean_author = article['author'].replace('By ', '')\n        \n        # Parse date\n        article_date = datetime.strptime(article['date'], '%Y-%m-%d')\n        \n        cleaned_article = {\n            'title': clean_title,\n            'author': clean_author,\n            'date': article_date.strftime('%B %d, %Y'),\n            'scraped_at': datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        }\n        \n        cleaned_articles.append(cleaned_article)\n    \n    return cleaned_articles\n\n# Process the data\nprocessed_articles = clean_and_process_data(scraped_data)\n\n# Display processed data\nprint(\"Processed Articles:\")\nfor article in processed_articles:\n    print(f\"📰 {article['title']}\")\n    print(f\"✍️  {article['author']}\")\n    print(f\"📅 {article['date']}\")\n    print(f\"🕒 Scraped: {article['scraped_at']}\")\n    print(\"-\" * 40)\n\n# Save to JSON (simulation)\nprint(f\"\\nSaved {len(processed_articles)} articles to database\")",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Extract Email Addresses",
        "description": "Write a function to extract email addresses from text using string methods.",
        "starterCode": "def extract_emails(text):\n    # Extract email addresses from text\n    pass\n\n# Test data\ntext = \"Contact us at info@company.com or support@help.org for assistance.\"\nprint(extract_emails(text))",
        "expectedOutput": "['info@company.com', 'support@help.org']",
        "solution": "def extract_emails(text):\n    emails = []\n    words = text.split()\n    for word in words:\n        if '@' in word and '.' in word:\n            # Clean punctuation\n            email = word.strip('.,!?;:')\n            emails.append(email)\n    return emails"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Price Monitor",
        "description": "Create a price monitoring function that tracks price changes from simulated product data.",
        "starterCode": "def monitor_prices(current_prices, historical_prices):\n    # Compare current prices with historical data\n    pass\n\n# Test data\ncurrent = {'laptop': 999, 'phone': 699, 'tablet': 399}\nhistorical = {'laptop': 1099, 'phone': 699, 'tablet': 449}\n\nprint(monitor_prices(current, historical))",
        "expectedOutput": "{'laptop': -100, 'phone': 0, 'tablet': -50}",
        "solution": "def monitor_prices(current_prices, historical_prices):\n    price_changes = {}\n    for product in current_prices:\n        if product in historical_prices:\n            change = current_prices[product] - historical_prices[product]\n            price_changes[product] = change\n    return price_changes"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Data Aggregator",
        "description": "Build a function that aggregates and analyzes scraped data with statistics.",
        "starterCode": "def analyze_scraped_data(articles):\n    # Analyze article data and return insights\n    pass\n\n# Test data\narticles = [\n    {'author': 'Alice', 'date': '2024-01-15', 'category': 'tech'},\n    {'author': 'Bob', 'date': '2024-01-14', 'category': 'tech'},\n    {'author': 'Alice', 'date': '2024-01-13', 'category': 'science'}\n]\n\nprint(analyze_scraped_data(articles))",
        "expectedOutput": "{'total_articles': 3, 'authors': {'Alice': 2, 'Bob': 1}, 'categories': {'tech': 2, 'science': 1}}",
        "solution": "def analyze_scraped_data(articles):\n    analysis = {\n        'total_articles': len(articles),\n        'authors': {},\n        'categories': {}\n    }\n    \n    for article in articles:\n        # Count by author\n        author = article['author']\n        analysis['authors'][author] = analysis['authors'].get(author, 0) + 1\n        \n        # Count by category\n        category = article['category']\n        analysis['categories'][category] = analysis['categories'].get(category, 0) + 1\n    \n    return analysis"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What should you always check before scraping a website?",
        "type": "multiple-choice",
        "options": ["The website's color scheme", "The robots.txt file and terms of service", "The number of pages", "The website's age"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which Python library is commonly used for parsing HTML?",
        "type": "multiple-choice",
        "options": ["requests", "BeautifulSoup", "json", "datetime"],
        "correctAnswer": 1
      },
      {
        "id": "q3",
        "question": "Why is rate limiting important in web scraping?",
        "type": "multiple-choice",
        "options": ["To make code run faster", "To avoid overloading the target server", "To use less memory", "To improve data quality"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "data-science-intro",
    "title": "Data Science with Python",
    "description": "Explore data analysis, visualization, and machine learning fundamentals using Python.",
    "category": "Data Science",
    "difficulty": "advanced",
    "estimatedTime": 35,
    "xpReward": 150,
    "prerequisites": ["python-dictionaries", "python-functions", "python-modules"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Introduction to Data Science",
        "content": "Data Science is an interdisciplinary field that uses scientific methods, processes, algorithms, and systems to extract knowledge and insights from structured and unstructured data.\n\nKey components of Data Science:\n• Data Collection: Gathering data from various sources\n• Data Cleaning: Preparing and cleaning raw data\n• Exploratory Data Analysis (EDA): Understanding data patterns\n• Statistical Analysis: Applying statistical methods\n• Machine Learning: Building predictive models\n• Data Visualization: Creating charts and graphs\n• Communication: Presenting findings effectively\n\nPython libraries commonly used:\n• pandas: Data manipulation and analysis\n• numpy: Numerical computing\n• matplotlib/seaborn: Data visualization\n• scikit-learn: Machine learning\n• jupyter: Interactive notebooks"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Working with Data Structures",
        "content": "Let's work with data using Python's built-in structures (simulating pandas functionality):",
        "code": "# Sample sales data\nsales_data = [\n    {'date': '2024-01-01', 'product': 'Laptop', 'quantity': 5, 'price': 999, 'region': 'North'},\n    {'date': '2024-01-01', 'product': 'Phone', 'quantity': 12, 'price': 699, 'region': 'South'},\n    {'date': '2024-01-02', 'product': 'Tablet', 'quantity': 8, 'price': 399, 'region': 'North'},\n    {'date': '2024-01-02', 'product': 'Laptop', 'quantity': 3, 'price': 999, 'region': 'East'},\n    {'date': '2024-01-03', 'product': 'Phone', 'quantity': 15, 'price': 699, 'region': 'West'}\n]\n\n# Calculate total revenue for each sale\nfor sale in sales_data:\n    sale['revenue'] = sale['quantity'] * sale['price']\n    print(f\"{sale['date']}: {sale['product']} - ${sale['revenue']}\")\n\nprint(\"\\n\" + \"=\"*50)\n\n# Data aggregation - total revenue by product\nrevenue_by_product = {}\nfor sale in sales_data:\n    product = sale['product']\n    revenue = sale['revenue']\n    revenue_by_product[product] = revenue_by_product.get(product, 0) + revenue\n\nprint(\"Revenue by Product:\")\nfor product, revenue in revenue_by_product.items():\n    print(f\"{product}: ${revenue:,}\")",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Statistical Analysis",
        "content": "Let's perform basic statistical analysis on our data:",
        "code": "# Extract numerical data for analysis\nrevenues = [sale['revenue'] for sale in sales_data]\nquantities = [sale['quantity'] for sale in sales_data]\nprices = [sale['price'] for sale in sales_data]\n\ndef calculate_statistics(data):\n    \"\"\"Calculate basic statistics for a list of numbers\"\"\"\n    n = len(data)\n    \n    # Mean (average)\n    mean = sum(data) / n\n    \n    # Median (middle value)\n    sorted_data = sorted(data)\n    if n % 2 == 0:\n        median = (sorted_data[n//2 - 1] + sorted_data[n//2]) / 2\n    else:\n        median = sorted_data[n//2]\n    \n    # Mode (most frequent value)\n    frequency = {}\n    for value in data:\n        frequency[value] = frequency.get(value, 0) + 1\n    mode = max(frequency, key=frequency.get)\n    \n    # Range\n    data_range = max(data) - min(data)\n    \n    # Standard deviation (simplified)\n    variance = sum((x - mean) ** 2 for x in data) / n\n    std_dev = variance ** 0.5\n    \n    return {\n        'mean': round(mean, 2),\n        'median': median,\n        'mode': mode,\n        'range': data_range,\n        'min': min(data),\n        'max': max(data),\n        'std_dev': round(std_dev, 2)\n    }\n\n# Analyze revenue data\nrevenue_stats = calculate_statistics(revenues)\nprint(\"Revenue Statistics:\")\nfor stat, value in revenue_stats.items():\n    print(f\"{stat.title()}: ${value:,}\" if 'revenue' in stat or stat in ['mean', 'median', 'mode', 'range', 'min', 'max'] else f\"{stat.title()}: {value}\")\n\nprint(\"\\nQuantity Statistics:\")\nquantity_stats = calculate_statistics(quantities)\nfor stat, value in quantity_stats.items():\n    print(f\"{stat.title()}: {value}\")",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Data Visualization Concepts",
        "content": "Let's create a simple text-based visualization and understand chart types:",
        "code": "# Create a simple bar chart using text\ndef create_text_bar_chart(data, title):\n    \"\"\"Create a simple text-based bar chart\"\"\"\n    print(f\"\\n{title}\")\n    print(\"=\" * len(title))\n    \n    max_value = max(data.values())\n    scale_factor = 30 / max_value  # Scale to fit in 30 characters\n    \n    for label, value in data.items():\n        bar_length = int(value * scale_factor)\n        bar = \"█\" * bar_length\n        print(f\"{label:10} |{bar} ${value:,}\")\n    \n    print()\n\n# Visualize revenue by product\ncreate_text_bar_chart(revenue_by_product, \"Revenue by Product\")\n\n# Regional analysis\nrevenue_by_region = {}\nfor sale in sales_data:\n    region = sale['region']\n    revenue = sale['revenue']\n    revenue_by_region[region] = revenue_by_region.get(region, 0) + revenue\n\ncreate_text_bar_chart(revenue_by_region, \"Revenue by Region\")\n\n# Data insights\nprint(\"Key Insights:\")\nprint(f\"• Total Revenue: ${sum(revenues):,}\")\nprint(f\"• Average Sale: ${sum(revenues)/len(revenues):,.2f}\")\nprint(f\"• Best Selling Product: {max(revenue_by_product, key=revenue_by_product.get)}\")\nprint(f\"• Top Region: {max(revenue_by_region, key=revenue_by_region.get)}\")\n\n# Correlation analysis (simplified)\nprint(f\"\\nCorrelation Analysis:\")\nprint(f\"• Higher quantities don't always mean higher revenue\")\nprint(f\"• Product price significantly impacts total revenue\")\nprint(f\"• Regional performance varies significantly\")",
        "language": "python"
      },
      {
        "id": "step-5",
        "type": "code",
        "title": "Simple Machine Learning Concept",
        "content": "Let's implement a basic linear regression to predict sales:",
        "code": "# Simple linear regression to predict revenue based on quantity\ndef simple_linear_regression(x_data, y_data):\n    \"\"\"Calculate linear regression coefficients\"\"\"\n    n = len(x_data)\n    \n    # Calculate means\n    x_mean = sum(x_data) / n\n    y_mean = sum(y_data) / n\n    \n    # Calculate slope (m) and intercept (b) for y = mx + b\n    numerator = sum((x_data[i] - x_mean) * (y_data[i] - y_mean) for i in range(n))\n    denominator = sum((x_data[i] - x_mean) ** 2 for i in range(n))\n    \n    slope = numerator / denominator if denominator != 0 else 0\n    intercept = y_mean - slope * x_mean\n    \n    return slope, intercept\n\ndef predict_revenue(quantity, slope, intercept):\n    \"\"\"Predict revenue based on quantity\"\"\"\n    return slope * quantity + intercept\n\n# Use quantity to predict revenue\nquantities = [sale['quantity'] for sale in sales_data]\nrevenues = [sale['revenue'] for sale in sales_data]\n\nslope, intercept = simple_linear_regression(quantities, revenues)\n\nprint(\"Linear Regression Model:\")\nprint(f\"Revenue = {slope:.2f} * Quantity + {intercept:.2f}\")\nprint()\n\n# Make predictions\nprint(\"Predictions vs Actual:\")\nprint(\"Quantity | Predicted | Actual   | Difference\")\nprint(\"-\" * 45)\n\nfor i, (qty, actual) in enumerate(zip(quantities, revenues)):\n    predicted = predict_revenue(qty, slope, intercept)\n    difference = abs(predicted - actual)\n    print(f\"{qty:8} | ${predicted:8.0f} | ${actual:8} | ${difference:8.0f}\")\n\n# Test with new data\nprint(\"\\nNew Predictions:\")\ntest_quantities = [10, 20, 30]\nfor qty in test_quantities:\n    predicted = predict_revenue(qty, slope, intercept)\n    print(f\"If quantity = {qty}, predicted revenue = ${predicted:,.0f}\")",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Data Summary",
        "description": "Write a function to calculate basic summary statistics for a dataset.",
        "starterCode": "def summarize_data(numbers):\n    # Calculate count, sum, average, min, max\n    pass\n\n# Test data\ndata = [10, 15, 20, 25, 30, 35, 40]\nprint(summarize_data(data))",
        "expectedOutput": "{'count': 7, 'sum': 175, 'average': 25.0, 'min': 10, 'max': 40}",
        "solution": "def summarize_data(numbers):\n    if not numbers:\n        return {}\n    \n    return {\n        'count': len(numbers),\n        'sum': sum(numbers),\n        'average': sum(numbers) / len(numbers),\n        'min': min(numbers),\n        'max': max(numbers)\n    }"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Data Grouping",
        "description": "Create a function that groups data by category and calculates totals.",
        "starterCode": "def group_and_sum(data, group_key, sum_key):\n    # Group data and calculate sums\n    pass\n\n# Test data\nsales = [\n    {'category': 'Electronics', 'amount': 1000},\n    {'category': 'Clothing', 'amount': 500},\n    {'category': 'Electronics', 'amount': 1500},\n    {'category': 'Clothing', 'amount': 300}\n]\n\nprint(group_and_sum(sales, 'category', 'amount'))",
        "expectedOutput": "{'Electronics': 2500, 'Clothing': 800}",
        "solution": "def group_and_sum(data, group_key, sum_key):\n    result = {}\n    for item in data:\n        category = item[group_key]\n        amount = item[sum_key]\n        result[category] = result.get(category, 0) + amount\n    return result"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Moving Average",
        "description": "Implement a function to calculate moving averages for time series data.",
        "starterCode": "def moving_average(data, window_size):\n    # Calculate moving averages\n    pass\n\n# Test data\nprices = [100, 102, 101, 103, 105, 104, 106, 108, 107, 109]\nwindow = 3\nprint(moving_average(prices, window))",
        "expectedOutput": "[101.0, 102.0, 103.0, 104.0, 105.0, 106.0, 107.0, 108.0]",
        "solution": "def moving_average(data, window_size):\n    if window_size > len(data):\n        return []\n    \n    moving_averages = []\n    for i in range(len(data) - window_size + 1):\n        window_sum = sum(data[i:i + window_size])\n        avg = window_sum / window_size\n        moving_averages.append(avg)\n    \n    return moving_averages"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What is the first step in most data science projects?",
        "type": "multiple-choice",
        "options": ["Building models", "Data collection and cleaning", "Creating visualizations", "Writing reports"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which statistical measure is most affected by outliers?",
        "type": "multiple-choice",
        "options": ["Median", "Mode", "Mean", "Range"],
        "correctAnswer": 2
      },
      {
        "id": "q3",
        "question": "What does linear regression help us do?",
        "type": "multiple-choice",
        "options": ["Sort data", "Predict values based on relationships", "Clean data", "Visualize data"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "advanced-data-structures",
    "title": "Advanced Data Structures",
    "description": "Master collections, heaps, trees, and graph structures in Python.",
    "category": "Advanced Data Structures",
    "difficulty": "advanced",
    "estimatedTime": 40,
    "xpReward": 150,
    "prerequisites": ["python-dictionaries", "python-functions", "algorithms-intro"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Collections Module",
        "content": "Python's collections module provides specialized container datatypes beyond basic lists, dicts, sets, and tuples:\n\n• Counter: Count hashable objects\n• defaultdict: Dictionary with default values\n• OrderedDict: Dictionary that remembers insertion order\n• deque: Double-ended queue\n• namedtuple: Tuple subclass with named fields\n• ChainMap: Combine multiple mappings\n\nThese are essential for writing efficient, Pythonic code."
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Counter and DefaultDict",
        "content": "Powerful tools for counting and grouping data:",
        "code": "from collections import Counter, defaultdict\n\n# Counter for frequency counting\ntext = \"hello world hello python\"\nword_count = Counter(text.split())\nprint(\"Word frequencies:\", word_count)\nprint(\"Most common:\", word_count.most_common(2))\n\n# Counter with lists\nnumbers = [1, 2, 2, 3, 3, 3, 4]\nnum_count = Counter(numbers)\nprint(\"Number frequencies:\", num_count)\n\n# DefaultDict for grouping\nstudents = [\n    ('Alice', 'Math'), ('Bob', 'Science'), ('Alice', 'English'),\n    ('Charlie', 'Math'), ('Bob', 'Math')\n]\n\n# Group courses by student\nstudent_courses = defaultdict(list)\nfor name, course in students:\n    student_courses[name].append(course)\n\nfor student, courses in student_courses.items():\n    print(f\"{student}: {', '.join(courses)}\")",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Deque and NamedTuple",
        "content": "Efficient queue operations and structured data:",
        "code": "from collections import deque, namedtuple\n\n# Deque for efficient operations at both ends\nqueue = deque(['first', 'second', 'third'])\nqueue.appendleft('new_first')  # Add to left\nqueue.append('new_last')       # Add to right\n\nprint(\"Queue:\", queue)\nprint(\"Pop left:\", queue.popleft())\nprint(\"Pop right:\", queue.pop())\nprint(\"Remaining:\", queue)\n\n# NamedTuple for structured data\nPoint = namedtuple('Point', ['x', 'y'])\nStudent = namedtuple('Student', ['name', 'age', 'grade'])\n\n# Create instances\np1 = Point(10, 20)\nstudent = Student('Alice', 20, 'A')\n\nprint(f\"Point: x={p1.x}, y={p1.y}\")\nprint(f\"Student: {student.name}, Age: {student.age}, Grade: {student.grade}\")\n\n# NamedTuples are immutable but you can create new ones\nnew_student = student._replace(grade='A+')\nprint(f\"Updated: {new_student}\")",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Heaps and Priority Queues",
        "content": "Implement priority queues using heaps:",
        "code": "import heapq\n\n# Min heap operations\nheap = []\nheapq.heappush(heap, 3)\nheapq.heappush(heap, 1)\nheapq.heappush(heap, 4)\nheapq.heappush(heap, 1)\nheapq.heappush(heap, 5)\n\nprint(\"Heap:\", heap)\nprint(\"Smallest:\", heapq.heappop(heap))\nprint(\"After pop:\", heap)\n\n# Create heap from existing list\nnumbers = [3, 7, 1, 9, 4, 6, 2]\nheapq.heapify(numbers)\nprint(\"Heapified:\", numbers)\n\n# N largest/smallest elements\ndata = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]\nprint(\"3 largest:\", heapq.nlargest(3, data))\nprint(\"3 smallest:\", heapq.nsmallest(3, data))\n\n# Priority queue simulation\ntasks = [(3, 'Low priority'), (1, 'High priority'), (2, 'Medium priority')]\nheapq.heapify(tasks)\n\nprint(\"\\nProcessing tasks by priority:\")\nwhile tasks:\n    priority, task = heapq.heappop(tasks)\n    print(f\"Priority {priority}: {task}\")",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Word Frequency Counter",
        "description": "Use Counter to find the most common words in a text.",
        "starterCode": "from collections import Counter\n\ndef analyze_text(text):\n    # Count word frequencies\n    pass\n\ntext = \"the quick brown fox jumps over the lazy dog the fox\"\nprint(analyze_text(text))",
        "expectedOutput": "Most common: [('the', 3), ('fox', 2), ('quick', 1)]",
        "solution": "from collections import Counter\n\ndef analyze_text(text):\n    words = text.lower().split()\n    counter = Counter(words)\n    return counter.most_common()\n\ntext = \"the quick brown fox jumps over the lazy dog the fox\"\nresult = analyze_text(text)\nprint(\"Most common:\", result[:3])"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Task Scheduler",
        "description": "Implement a priority task scheduler using heapq.",
        "starterCode": "import heapq\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = []\n    \n    def add_task(self, priority, description):\n        # Add task with priority\n        pass\n    \n    def get_next_task(self):\n        # Get highest priority task\n        pass\n\nscheduler = TaskScheduler()\nscheduler.add_task(2, \"Medium task\")\nscheduler.add_task(1, \"High priority task\")\nprint(scheduler.get_next_task())",
        "expectedOutput": "High priority task",
        "solution": "import heapq\n\nclass TaskScheduler:\n    def __init__(self):\n        self.tasks = []\n    \n    def add_task(self, priority, description):\n        heapq.heappush(self.tasks, (priority, description))\n    \n    def get_next_task(self):\n        if self.tasks:\n            priority, description = heapq.heappop(self.tasks)\n            return description\n        return None"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Graph Representation",
        "description": "Implement a graph using defaultdict and demonstrate BFS traversal.",
        "starterCode": "from collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n    \n    def add_edge(self, u, v):\n        # Add bidirectional edge\n        pass\n    \n    def bfs(self, start):\n        # Breadth-first search\n        pass\n\ng = Graph()\ng.add_edge('A', 'B')\ng.add_edge('A', 'C')\ng.add_edge('B', 'D')\nprint(g.bfs('A'))",
        "expectedOutput": "['A', 'B', 'C', 'D']",
        "solution": "from collections import defaultdict, deque\n\nclass Graph:\n    def __init__(self):\n        self.graph = defaultdict(list)\n    \n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n    \n    def bfs(self, start):\n        visited = set()\n        queue = deque([start])\n        result = []\n        \n        while queue:\n            vertex = queue.popleft()\n            if vertex not in visited:\n                visited.add(vertex)\n                result.append(vertex)\n                queue.extend([n for n in self.graph[vertex] if n not in visited])\n        \n        return result"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What is the time complexity of heappop operation?",
        "type": "multiple-choice",
        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which collection is best for counting frequencies?",
        "type": "multiple-choice",
        "options": ["defaultdict", "deque", "Counter", "namedtuple"],
        "correctAnswer": 2
      }
    ]
  },
  {
    "id": "async-programming",
    "title": "Asynchronous Programming",
    "description": "Master async/await, coroutines, and concurrent programming in Python.",
    "category": "Async Programming",
    "difficulty": "advanced",
    "estimatedTime": 45,
    "xpReward": 200,
    "prerequisites": ["python-functions", "python-modules"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Understanding Asynchronous Programming",
        "content": "Asynchronous programming allows your program to perform other tasks while waiting for slow operations (I/O, network requests, file operations) to complete. This is especially important for:\n\n• Web applications handling many users\n• Data processing pipelines\n• Network communication\n• File operations\n• Database queries\n\nKey concepts:\n• Coroutines: Functions that can pause and resume\n• Event loop: Manages and executes async tasks\n• Tasks: Wrapped coroutines that can run concurrently\n• Futures: Objects representing eventual results"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Basic Async/Await Syntax",
        "content": "Learn the fundamental async/await pattern:",
        "code": "import asyncio\nimport time\n\n# Synchronous function (blocking)\ndef sync_operation(name, duration):\n    print(f\"Starting {name}\")\n    time.sleep(duration)  # Simulates blocking operation\n    print(f\"Finished {name}\")\n    return f\"Result from {name}\"\n\n# Asynchronous function (non-blocking)\nasync def async_operation(name, duration):\n    print(f\"Starting {name}\")\n    await asyncio.sleep(duration)  # Non-blocking sleep\n    print(f\"Finished {name}\")\n    return f\"Result from {name}\"\n\n# Run synchronous operations (sequential)\nprint(\"=== Synchronous Execution ===\")\nstart_time = time.time()\nsync_operation(\"Task 1\", 2)\nsync_operation(\"Task 2\", 2)\nsync_operation(\"Task 3\", 2)\nprint(f\"Total time: {time.time() - start_time:.2f} seconds\")\n\n# Run asynchronous operations (concurrent)\nasync def main():\n    print(\"\\n=== Asynchronous Execution ===\")\n    start_time = time.time()\n    \n    # Create tasks that run concurrently\n    task1 = asyncio.create_task(async_operation(\"Task 1\", 2))\n    task2 = asyncio.create_task(async_operation(\"Task 2\", 2))\n    task3 = asyncio.create_task(async_operation(\"Task 3\", 2))\n    \n    # Wait for all tasks to complete\n    results = await asyncio.gather(task1, task2, task3)\n    print(f\"Results: {results}\")\n    print(f\"Total time: {time.time() - start_time:.2f} seconds\")\n\n# Run the async main function\nasyncio.run(main())",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Working with Multiple Tasks",
        "content": "Advanced patterns for managing concurrent tasks:",
        "code": "import asyncio\nimport random\n\nasync def fetch_data(url_id, delay=None):\n    \"\"\"Simulate fetching data from an API\"\"\"\n    if delay is None:\n        delay = random.uniform(1, 3)\n    \n    print(f\"Fetching data from URL {url_id}...\")\n    await asyncio.sleep(delay)\n    \n    # Simulate occasional failures\n    if random.random() < 0.2:\n        raise Exception(f\"Failed to fetch from URL {url_id}\")\n    \n    return {\"url_id\": url_id, \"data\": f\"Data from {url_id}\", \"delay\": delay}\n\nasync def process_data(data):\n    \"\"\"Simulate processing fetched data\"\"\"\n    print(f\"Processing data from URL {data['url_id']}\")\n    await asyncio.sleep(0.5)\n    return f\"Processed: {data['data']}\"\n\nasync def fetch_with_timeout():\n    \"\"\"Demonstrate timeout handling\"\"\"\n    print(\"\\n=== Timeout Example ===\")\n    try:\n        # This will timeout after 2 seconds\n        result = await asyncio.wait_for(fetch_data(\"slow-api\", 5), timeout=2.0)\n        print(f\"Success: {result}\")\n    except asyncio.TimeoutError:\n        print(\"Operation timed out!\")\n\nasync def fetch_with_error_handling():\n    \"\"\"Demonstrate error handling in concurrent tasks\"\"\"\n    print(\"\\n=== Error Handling Example ===\")\n    tasks = [fetch_data(i) for i in range(1, 6)]\n    \n    # as_completed returns tasks as they finish\n    for completed_task in asyncio.as_completed(tasks):\n        try:\n            result = await completed_task\n            processed = await process_data(result)\n            print(f\"Success: {processed}\")\n        except Exception as e:\n            print(f\"Error: {e}\")\n\nasync def main():\n    await fetch_with_timeout()\n    await fetch_with_error_handling()\n\n# Run the examples\nasyncio.run(main())",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Producer-Consumer Pattern",
        "content": "Implement async queues for producer-consumer scenarios:",
        "code": "import asyncio\nimport random\n\nasync def producer(name, queue, num_items):\n    \"\"\"Produce items and put them in the queue\"\"\"\n    print(f\"Producer {name} starting...\")\n    \n    for i in range(num_items):\n        # Simulate time to produce an item\n        await asyncio.sleep(random.uniform(0.1, 0.5))\n        \n        item = f\"{name}-item-{i+1}\"\n        await queue.put(item)\n        print(f\"Producer {name} produced: {item}\")\n    \n    print(f\"Producer {name} finished\")\n\nasync def consumer(name, queue):\n    \"\"\"Consume items from the queue\"\"\"\n    print(f\"Consumer {name} starting...\")\n    \n    while True:\n        try:\n            # Wait for an item with timeout\n            item = await asyncio.wait_for(queue.get(), timeout=2.0)\n            \n            # Simulate time to process the item\n            await asyncio.sleep(random.uniform(0.2, 0.8))\n            \n            print(f\"Consumer {name} processed: {item}\")\n            queue.task_done()\n            \n        except asyncio.TimeoutError:\n            print(f\"Consumer {name} timed out, stopping\")\n            break\n\nasync def producer_consumer_example():\n    \"\"\"Demonstrate producer-consumer pattern with asyncio.Queue\"\"\"\n    # Create a queue with maximum size\n    queue = asyncio.Queue(maxsize=5)\n    \n    # Create multiple producers and consumers\n    producers = [\n        asyncio.create_task(producer(\"P1\", queue, 3)),\n        asyncio.create_task(producer(\"P2\", queue, 3))\n    ]\n    \n    consumers = [\n        asyncio.create_task(consumer(\"C1\", queue)),\n        asyncio.create_task(consumer(\"C2\", queue))\n    ]\n    \n    # Wait for all producers to finish\n    await asyncio.gather(*producers)\n    \n    # Wait for all items in queue to be processed\n    await queue.join()\n    \n    # Cancel consumers (they run indefinitely)\n    for consumer_task in consumers:\n        consumer_task.cancel()\n    \n    print(\"All items produced and processed!\")\n\n# Run the producer-consumer example\nasyncio.run(producer_consumer_example())",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Async Timer",
        "description": "Create an async function that acts as a countdown timer.",
        "starterCode": "import asyncio\n\nasync def countdown_timer(seconds):\n    # Implement countdown from seconds to 0\n    pass\n\n# Test the timer\nasyncio.run(countdown_timer(5))",
        "expectedOutput": "5\n4\n3\n2\n1\n0\nTime's up!",
        "solution": "import asyncio\n\nasync def countdown_timer(seconds):\n    for i in range(seconds, -1, -1):\n        print(i)\n        if i > 0:\n            await asyncio.sleep(1)\n    print(\"Time's up!\")"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Concurrent Downloads",
        "description": "Simulate downloading multiple files concurrently with progress tracking.",
        "starterCode": "import asyncio\nimport random\n\nasync def download_file(filename, size_mb):\n    # Simulate file download with progress\n    pass\n\nasync def main():\n    files = [(\"file1.zip\", 100), (\"file2.mp4\", 250), (\"file3.pdf\", 50)]\n    # Download all files concurrently\n    pass\n\nasyncio.run(main())",
        "expectedOutput": "Starting download: file1.zip (100 MB)\nStarting download: file2.mp4 (250 MB)\nCompleted: file1.zip\nCompleted: file3.pdf\nCompleted: file2.mp4\nAll downloads finished!",
        "solution": "import asyncio\nimport random\n\nasync def download_file(filename, size_mb):\n    print(f\"Starting download: {filename} ({size_mb} MB)\")\n    # Simulate download time based on file size\n    download_time = size_mb / 100  # 100 MB per second\n    await asyncio.sleep(download_time)\n    print(f\"Completed: {filename}\")\n    return filename\n\nasync def main():\n    files = [(\"file1.zip\", 100), (\"file2.mp4\", 250), (\"file3.pdf\", 50)]\n    tasks = [download_file(filename, size) for filename, size in files]\n    await asyncio.gather(*tasks)\n    print(\"All downloads finished!\")"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Rate Limited API Client",
        "description": "Implement an async API client with rate limiting and retry logic.",
        "starterCode": "import asyncio\nimport random\nfrom typing import List\n\nclass RateLimitedClient:\n    def __init__(self, requests_per_second: int):\n        self.rate_limit = requests_per_second\n        # Add rate limiting implementation\n        pass\n    \n    async def make_request(self, url: str) -> dict:\n        # Implement rate-limited request with retry\n        pass\n\n# Test the client\nasync def main():\n    client = RateLimitedClient(2)  # 2 requests per second\n    urls = [f\"api/endpoint/{i}\" for i in range(10)]\n    results = await asyncio.gather(*[client.make_request(url) for url in urls])\n    print(f\"Completed {len(results)} requests\")\n\nasyncio.run(main())",
        "expectedOutput": "Making request to api/endpoint/0\nRate limited, waiting...\nCompleted 10 requests",
        "solution": "import asyncio\nimport random\nfrom typing import List\n\nclass RateLimitedClient:\n    def __init__(self, requests_per_second: int):\n        self.rate_limit = requests_per_second\n        self.last_request_time = 0\n        self.semaphore = asyncio.Semaphore(requests_per_second)\n    \n    async def make_request(self, url: str) -> dict:\n        async with self.semaphore:\n            # Rate limiting\n            now = asyncio.get_event_loop().time()\n            time_since_last = now - self.last_request_time\n            min_interval = 1.0 / self.rate_limit\n            \n            if time_since_last < min_interval:\n                wait_time = min_interval - time_since_last\n                print(\"Rate limited, waiting...\")\n                await asyncio.sleep(wait_time)\n            \n            self.last_request_time = asyncio.get_event_loop().time()\n            \n            # Simulate API request with potential failure\n            print(f\"Making request to {url}\")\n            await asyncio.sleep(0.1)  # Simulate network delay\n            \n            if random.random() < 0.1:  # 10% failure rate\n                raise Exception(f\"Request failed for {url}\")\n            \n            return {\"url\": url, \"status\": \"success\"}"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What keyword is used to pause execution of an async function?",
        "type": "multiple-choice",
        "options": ["wait", "await", "pause", "yield"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which function is used to run multiple async tasks concurrently?",
        "type": "multiple-choice",
        "options": ["asyncio.run()", "asyncio.gather()", "asyncio.create_task()", "asyncio.wait()"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "testing-debugging",
    "title": "Testing and Debugging",
    "description": "Master unit testing, debugging techniques, and code quality assurance.",
    "category": "Testing & Debugging",
    "difficulty": "advanced",
    "estimatedTime": 35,
    "xpReward": 180,
    "prerequisites": ["python-functions", "python-classes"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Testing Fundamentals",
        "content": "Testing is crucial for reliable software development. Python provides excellent testing frameworks:\n\n• unittest: Built-in testing framework\n• pytest: Popular third-party framework\n• doctest: Tests embedded in docstrings\n• mock: Create fake objects for testing\n\nTesting types:\n• Unit tests: Test individual functions/methods\n• Integration tests: Test component interactions\n• Functional tests: Test complete workflows\n• Performance tests: Test speed and efficiency\n\nTesting principles:\n• Test early and often\n• Write tests before fixing bugs\n• Aim for high code coverage\n• Keep tests simple and focused"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Unit Testing with unittest",
        "content": "Learn Python's built-in testing framework:",
        "code": "import unittest\nfrom typing import List\n\n# Functions to test\ndef calculate_average(numbers: List[float]) -> float:\n    \"\"\"Calculate the average of a list of numbers.\"\"\"\n    if not numbers:\n        raise ValueError(\"Cannot calculate average of empty list\")\n    return sum(numbers) / len(numbers)\n\ndef is_prime(n: int) -> bool:\n    \"\"\"Check if a number is prime.\"\"\"\n    if n < 2:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    \n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\nclass TestMathFunctions(unittest.TestCase):\n    \"\"\"Test cases for mathematical functions.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures before each test method.\"\"\"\n        self.sample_numbers = [1, 2, 3, 4, 5]\n        self.empty_list = []\n    \n    def test_calculate_average_normal(self):\n        \"\"\"Test average calculation with normal input.\"\"\"\n        result = calculate_average(self.sample_numbers)\n        self.assertEqual(result, 3.0)\n    \n    def test_calculate_average_single_number(self):\n        \"\"\"Test average calculation with single number.\"\"\"\n        result = calculate_average([42])\n        self.assertEqual(result, 42.0)\n    \n    def test_calculate_average_empty_list(self):\n        \"\"\"Test that empty list raises ValueError.\"\"\"\n        with self.assertRaises(ValueError):\n            calculate_average(self.empty_list)\n    \n    def test_calculate_average_floats(self):\n        \"\"\"Test average calculation with floating point numbers.\"\"\"\n        result = calculate_average([1.5, 2.5, 3.5])\n        self.assertAlmostEqual(result, 2.5, places=2)\n    \n    def test_is_prime_small_primes(self):\n        \"\"\"Test prime checking for small prime numbers.\"\"\"\n        primes = [2, 3, 5, 7, 11, 13, 17, 19]\n        for prime in primes:\n            self.assertTrue(is_prime(prime), f\"{prime} should be prime\")\n    \n    def test_is_prime_non_primes(self):\n        \"\"\"Test prime checking for non-prime numbers.\"\"\"\n        non_primes = [0, 1, 4, 6, 8, 9, 10, 12, 15, 16]\n        for non_prime in non_primes:\n            self.assertFalse(is_prime(non_prime), f\"{non_prime} should not be prime\")\n    \n    def tearDown(self):\n        \"\"\"Clean up after each test method.\"\"\"\n        # Usually used to clean up resources\n        pass\n\n# Run the tests\nif __name__ == '__main__':\n    # Create a test suite\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestMathFunctions)\n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(suite)\n    \n    print(f\"\\nTests run: {result.testsRun}\")\n    print(f\"Failures: {len(result.failures)}\")\n    print(f\"Errors: {len(result.errors)}\")",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Debugging Techniques",
        "content": "Essential debugging tools and techniques:",
        "code": "import sys\nimport traceback\nfrom typing import List, Dict\n\n# Debugging with print statements\ndef debug_with_prints():\n    \"\"\"Demonstrate debugging with strategic print statements.\"\"\"\n    print(\"=== Debug with Prints ===\")\n    \n    def process_data(items: List[int]) -> List[int]:\n        print(f\"DEBUG: Processing {len(items)} items: {items}\")\n        result = []\n        \n        for i, item in enumerate(items):\n            print(f\"DEBUG: Processing item {i}: {item}\")\n            \n            if item > 0:\n                doubled = item * 2\n                print(f\"DEBUG: Doubled {item} to {doubled}\")\n                result.append(doubled)\n            else:\n                print(f\"DEBUG: Skipping non-positive item: {item}\")\n        \n        print(f\"DEBUG: Final result: {result}\")\n        return result\n    \n    test_data = [1, -2, 3, 0, 5]\n    result = process_data(test_data)\n    print(f\"Result: {result}\\n\")\n\n# Using assertions for debugging\ndef debug_with_assertions():\n    \"\"\"Demonstrate using assertions for debugging.\"\"\"\n    print(\"=== Debug with Assertions ===\")\n    \n    def calculate_rectangle_area(length: float, width: float) -> float:\n        # Assertions help catch invalid inputs early\n        assert length > 0, f\"Length must be positive, got {length}\"\n        assert width > 0, f\"Width must be positive, got {width}\"\n        assert isinstance(length, (int, float)), f\"Length must be numeric, got {type(length)}\"\n        assert isinstance(width, (int, float)), f\"Width must be numeric, got {type(width)}\"\n        \n        area = length * width\n        \n        # Post-condition assertion\n        assert area > 0, f\"Area calculation failed: {area}\"\n        \n        return area\n    \n    try:\n        print(\"Valid calculation:\")\n        area1 = calculate_rectangle_area(5, 3)\n        print(f\"Area: {area1}\")\n        \n        print(\"\\nInvalid calculation (negative width):\")\n        area2 = calculate_rectangle_area(5, -3)\n        \n    except AssertionError as e:\n        print(f\"Assertion failed: {e}\")\n    \n    print()\n\n# Exception handling and logging\ndef debug_with_exception_handling():\n    \"\"\"Demonstrate proper exception handling for debugging.\"\"\"\n    print(\"=== Debug with Exception Handling ===\")\n    \n    def divide_numbers(dividend: float, divisor: float) -> float:\n        try:\n            result = dividend / divisor\n            return result\n        except ZeroDivisionError:\n            print(f\"ERROR: Division by zero! dividend={dividend}, divisor={divisor}\")\n            traceback.print_exc()\n            raise\n        except TypeError as e:\n            print(f\"ERROR: Type error in division: {e}\")\n            print(f\"dividend type: {type(dividend)}, divisor type: {type(divisor)}\")\n            raise\n    \n    # Test cases\n    test_cases = [\n        (10, 2),     # Valid\n        (10, 0),     # Division by zero\n        (\"10\", 2),   # Type error\n    ]\n    \n    for dividend, divisor in test_cases:\n        try:\n            result = divide_numbers(dividend, divisor)\n            print(f\"Result: {dividend} / {divisor} = {result}\")\n        except Exception as e:\n            print(f\"Failed to divide {dividend} by {divisor}: {type(e).__name__}\")\n        print()\n\n# Simple profiling for performance debugging\ndef debug_performance():\n    \"\"\"Demonstrate simple performance debugging.\"\"\"\n    print(\"=== Performance Debugging ===\")\n    import time\n    \n    def time_function(func, *args, **kwargs):\n        \"\"\"Measure execution time of a function.\"\"\"\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    \n    def slow_sum(n: int) -> int:\n        \"\"\"Intentionally slow sum calculation.\"\"\"\n        total = 0\n        for i in range(n):\n            total += i\n        return total\n    \n    def fast_sum(n: int) -> int:\n        \"\"\"Fast sum using formula.\"\"\"\n        return n * (n - 1) // 2\n    \n    n = 100000\n    print(f\"Calculating sum of numbers from 0 to {n-1}:\")\n    \n    slow_result = time_function(slow_sum, n)\n    fast_result = time_function(fast_sum, n)\n    \n    print(f\"Slow result: {slow_result}\")\n    print(f\"Fast result: {fast_result}\")\n    print(f\"Results match: {slow_result == fast_result}\")\n\n# Run all debugging examples\nif __name__ == \"__main__\":\n    debug_with_prints()\n    debug_with_assertions()\n    debug_with_exception_handling()\n    debug_performance()",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Mocking and Test Isolation",
        "content": "Learn to isolate tests using mocks and patches:",
        "code": "import unittest\nfrom unittest.mock import Mock, patch, MagicMock\nimport random\nimport datetime\n\n# Code to be tested\nclass WeatherService:\n    \"\"\"Service for fetching weather data.\"\"\"\n    \n    def get_temperature(self, city: str) -> float:\n        \"\"\"Simulate API call to get temperature.\"\"\"\n        # In real code, this would make an HTTP request\n        import time\n        time.sleep(0.1)  # Simulate network delay\n        \n        # Simulate random temperature data\n        return random.uniform(-10, 35)\n    \n    def get_weather_report(self, city: str) -> dict:\n        \"\"\"Get comprehensive weather report.\"\"\"\n        temperature = self.get_temperature(city)\n        \n        return {\n            'city': city,\n            'temperature': temperature,\n            'feels_like': temperature + random.uniform(-2, 2),\n            'timestamp': datetime.datetime.now().isoformat()\n        }\n\nclass WeatherAlert:\n    \"\"\"Alert system based on weather conditions.\"\"\"\n    \n    def __init__(self, weather_service: WeatherService):\n        self.weather_service = weather_service\n    \n    def check_heat_warning(self, city: str) -> bool:\n        \"\"\"Check if heat warning should be issued.\"\"\"\n        temperature = self.weather_service.get_temperature(city)\n        return temperature > 30\n    \n    def get_clothing_recommendation(self, city: str) -> str:\n        \"\"\"Recommend clothing based on temperature.\"\"\"\n        temperature = self.weather_service.get_temperature(city)\n        \n        if temperature < 0:\n            return \"Heavy winter coat and warm layers\"\n        elif temperature < 10:\n            return \"Warm jacket and long pants\"\n        elif temperature < 20:\n            return \"Light jacket or sweater\"\n        elif temperature < 30:\n            return \"T-shirt and light pants\"\n        else:\n            return \"Light, breathable clothing and sunscreen\"\n\nclass TestWeatherAlert(unittest.TestCase):\n    \"\"\"Test cases demonstrating mocking techniques.\"\"\"\n    \n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.weather_service = WeatherService()\n        self.weather_alert = WeatherAlert(self.weather_service)\n    \n    def test_heat_warning_with_mock(self):\n        \"\"\"Test heat warning using mock.\"\"\"\n        # Create a mock weather service\n        mock_weather_service = Mock()\n        mock_weather_service.get_temperature.return_value = 35.0\n        \n        # Use mock in our alert system\n        alert_system = WeatherAlert(mock_weather_service)\n        \n        # Test the method\n        result = alert_system.check_heat_warning(\"Phoenix\")\n        \n        # Assertions\n        self.assertTrue(result)\n        mock_weather_service.get_temperature.assert_called_once_with(\"Phoenix\")\n    \n    def test_no_heat_warning_with_mock(self):\n        \"\"\"Test no heat warning using mock.\"\"\"\n        mock_weather_service = Mock()\n        mock_weather_service.get_temperature.return_value = 25.0\n        \n        alert_system = WeatherAlert(mock_weather_service)\n        result = alert_system.check_heat_warning(\"Seattle\")\n        \n        self.assertFalse(result)\n        mock_weather_service.get_temperature.assert_called_once_with(\"Seattle\")\n    \n    @patch('random.uniform')\n    def test_weather_report_with_patch(self, mock_random):\n        \"\"\"Test weather report with patched random function.\"\"\"\n        # Control the random values\n        mock_random.side_effect = [25.0, 1.5]  # temperature, feels_like_diff\n        \n        with patch('datetime.datetime') as mock_datetime:\n            mock_datetime.now.return_value.isoformat.return_value = \"2024-01-15T12:00:00\"\n            \n            service = WeatherService()\n            with patch.object(service, 'get_temperature', return_value=25.0):\n                report = service.get_weather_report(\"Portland\")\n        \n        expected_report = {\n            'city': 'Portland',\n            'temperature': 25.0,\n            'feels_like': 26.5,\n            'timestamp': '2024-01-15T12:00:00'\n        }\n        \n        self.assertEqual(report, expected_report)\n    \n    def test_clothing_recommendations(self):\n        \"\"\"Test clothing recommendations for different temperatures.\"\"\"\n        test_cases = [\n            (-5, \"Heavy winter coat and warm layers\"),\n            (5, \"Warm jacket and long pants\"),\n            (15, \"Light jacket or sweater\"),\n            (25, \"T-shirt and light pants\"),\n            (35, \"Light, breathable clothing and sunscreen\")\n        ]\n        \n        for temperature, expected_recommendation in test_cases:\n            with self.subTest(temperature=temperature):\n                # Mock the weather service for each test case\n                with patch.object(self.weather_service, 'get_temperature', return_value=temperature):\n                    recommendation = self.weather_alert.get_clothing_recommendation(\"Test City\")\n                    self.assertEqual(recommendation, expected_recommendation)\n\n# Run the tests\nif __name__ == '__main__':\n    suite = unittest.TestLoader().loadTestsFromTestCase(TestWeatherAlert)\n    runner = unittest.TextTestRunner(verbosity=2)\n    result = runner.run(suite)\n    \n    print(f\"\\nMocking Tests Summary:\")\n    print(f\"Tests run: {result.testsRun}\")\n    print(f\"Failures: {len(result.failures)}\")\n    print(f\"Errors: {len(result.errors)}\")\n    \n    if result.wasSuccessful():\n        print(\"All tests passed! 🎉\")\n    else:\n        print(\"Some tests failed. Check the output above.\")",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Basic Test Case",
        "description": "Write a test case for a simple calculator function.",
        "starterCode": "import unittest\n\ndef add_numbers(a, b):\n    return a + b\n\nclass TestCalculator(unittest.TestCase):\n    def test_add_positive_numbers(self):\n        # Write your test here\n        pass\n\n# Run the test\nif __name__ == '__main__':\n    unittest.main()",
        "expectedOutput": "Test passes without errors",
        "solution": "import unittest\n\ndef add_numbers(a, b):\n    return a + b\n\nclass TestCalculator(unittest.TestCase):\n    def test_add_positive_numbers(self):\n        result = add_numbers(2, 3)\n        self.assertEqual(result, 5)\n    \n    def test_add_negative_numbers(self):\n        result = add_numbers(-1, -1)\n        self.assertEqual(result, -2)\n    \n    def test_add_zero(self):\n        result = add_numbers(5, 0)\n        self.assertEqual(result, 5)"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Exception Testing",
        "description": "Write tests that verify exceptions are raised correctly.",
        "starterCode": "import unittest\n\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\nclass TestDivision(unittest.TestCase):\n    def test_normal_division(self):\n        # Test normal division\n        pass\n    \n    def test_division_by_zero(self):\n        # Test that exception is raised\n        pass\n\nunittest.main()",
        "expectedOutput": "Tests verify both normal operation and exception handling",
        "solution": "import unittest\n\ndef divide(a, b):\n    if b == 0:\n        raise ValueError(\"Cannot divide by zero\")\n    return a / b\n\nclass TestDivision(unittest.TestCase):\n    def test_normal_division(self):\n        result = divide(10, 2)\n        self.assertEqual(result, 5.0)\n    \n    def test_division_by_zero(self):\n        with self.assertRaises(ValueError) as context:\n            divide(10, 0)\n        self.assertEqual(str(context.exception), \"Cannot divide by zero\")"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Mock External Service",
        "description": "Create tests using mocks to simulate external API calls.",
        "starterCode": "import unittest\nfrom unittest.mock import Mock, patch\n\nclass APIClient:\n    def fetch_user_data(self, user_id):\n        # Simulates external API call\n        raise NotImplementedError(\"External API call\")\n\nclass UserService:\n    def __init__(self, api_client):\n        self.api_client = api_client\n    \n    def get_user_info(self, user_id):\n        data = self.api_client.fetch_user_data(user_id)\n        return f\"User: {data['name']} ({data['email']})\"\n\nclass TestUserService(unittest.TestCase):\n    def test_get_user_info(self):\n        # Mock the API client and test the service\n        pass\n\nunittest.main()",
        "expectedOutput": "Test successfully mocks external API and verifies user service behavior",
        "solution": "import unittest\nfrom unittest.mock import Mock, patch\n\nclass APIClient:\n    def fetch_user_data(self, user_id):\n        raise NotImplementedError(\"External API call\")\n\nclass UserService:\n    def __init__(self, api_client):\n        self.api_client = api_client\n    \n    def get_user_info(self, user_id):\n        data = self.api_client.fetch_user_data(user_id)\n        return f\"User: {data['name']} ({data['email']})\"\n\nclass TestUserService(unittest.TestCase):\n    def test_get_user_info(self):\n        # Create mock API client\n        mock_api_client = Mock()\n        mock_api_client.fetch_user_data.return_value = {\n            'name': 'Alice Johnson',\n            'email': 'alice@example.com'\n        }\n        \n        # Test the service\n        user_service = UserService(mock_api_client)\n        result = user_service.get_user_info(123)\n        \n        # Verify the result\n        expected = \"User: Alice Johnson (alice@example.com)\"\n        self.assertEqual(result, expected)\n        \n        # Verify the API was called correctly\n        mock_api_client.fetch_user_data.assert_called_once_with(123)"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "Which assertion method checks if an exception is raised?",
        "type": "multiple-choice",
        "options": ["assertRaises", "assertException", "expectException", "checkRaises"],
        "correctAnswer": 0
      },
      {
        "id": "q2",
        "question": "What is the main purpose of mocking in unit tests?",
        "type": "multiple-choice",
        "options": ["To speed up tests", "To isolate the code being tested", "To reduce memory usage", "To make tests more complex"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "web-development-flask",
    "title": "Web Development with Flask",
    "description": "Build modern web applications using Flask framework with REST APIs and templates.",
    "category": "Web Development",
    "difficulty": "advanced",
    "estimatedTime": 50,
    "xpReward": 220,
    "prerequisites": ["python-functions", "python-classes", "python-dictionaries"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Flask Framework Fundamentals",
        "content": "Flask is a lightweight and flexible Python web framework that provides the essential tools and features for building web applications.\n\nKey Flask concepts:\n• Routes: Map URLs to Python functions\n• Templates: Generate dynamic HTML content\n• Request/Response: Handle HTTP requests and responses\n• Sessions: Maintain user state across requests\n• Blueprints: Organize large applications\n• Extensions: Add functionality (database, authentication, etc.)\n\nFlask philosophy:\n• Microframework - provides core functionality\n• Extensible through add-ons\n• Pythonic and flexible\n• Great for both small projects and large applications"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Basic Flask Application",
        "content": "Create a simple Flask web application with routes and templates:",
        "code": "# Simple Flask application structure\n# Note: This is educational - in real projects you'd install Flask\n\nclass MockFlask:\n    \"\"\"Simulated Flask app for educational purposes\"\"\"\n    def __init__(self, name):\n        self.name = name\n        self.routes = {}\n        self.templates = {}\n    \n    def route(self, path, methods=['GET']):\n        def decorator(func):\n            self.routes[path] = {\n                'function': func,\n                'methods': methods\n            }\n            return func\n        return decorator\n    \n    def run(self, debug=False, port=5000):\n        print(f\"Starting {self.name} on port {port}\")\n        print(f\"Debug mode: {debug}\")\n        print(\"Available routes:\")\n        for path, info in self.routes.items():\n            print(f\"  {info['methods']} {path} -> {info['function'].__name__}\")\n        \n        # Simulate handling requests\n        self.simulate_requests()\n    \n    def simulate_requests(self):\n        \"\"\"Simulate handling different HTTP requests\"\"\"\n        test_paths = ['/', '/users', '/users/123', '/api/data']\n        \n        for path in test_paths:\n            if path in self.routes:\n                print(f\"\\n📡 Request: GET {path}\")\n                response = self.routes[path]['function']()\n                print(f\"📤 Response: {response}\")\n            else:\n                print(f\"\\n📡 Request: GET {path}\")\n                print(f\"📤 Response: 404 Not Found\")\n\n# Create Flask app\napp = MockFlask(__name__)\n\n# Route definitions\n@app.route('/')\ndef home():\n    \"\"\"Home page route\"\"\"\n    return \"<h1>Welcome to PyLearn Web App!</h1><p>Learn Python web development</p>\"\n\n@app.route('/users')\ndef list_users():\n    \"\"\"List all users\"\"\"\n    users = ['Alice', 'Bob', 'Charlie', 'Diana']\n    user_list = '<br>'.join([f\"• {user}\" for user in users])\n    return f\"<h2>Users</h2>{user_list}\"\n\n@app.route('/users/<user_id>')\ndef get_user(user_id='123'):\n    \"\"\"Get specific user by ID\"\"\"\n    user_data = {\n        '123': {'name': 'Alice Johnson', 'role': 'Developer'},\n        '456': {'name': 'Bob Smith', 'role': 'Designer'},\n        '789': {'name': 'Charlie Brown', 'role': 'Manager'}\n    }\n    \n    if user_id in user_data:\n        user = user_data[user_id]\n        return f\"<h2>User {user_id}</h2><p>Name: {user['name']}<br>Role: {user['role']}</p>\"\n    else:\n        return \"<h2>User not found</h2>\", 404\n\n@app.route('/api/data', methods=['GET', 'POST'])\ndef api_data():\n    \"\"\"API endpoint returning JSON data\"\"\"\n    data = {\n        'status': 'success',\n        'data': {\n            'total_users': 4,\n            'active_sessions': 12,\n            'server_time': '2024-01-15T12:00:00Z'\n        },\n        'version': '1.0'\n    }\n    return str(data)  # Simulated JSON response\n\n# Run the application\nif __name__ == '__main__':\n    print(\"🚀 Starting Flask Web Application\")\n    app.run(debug=True, port=5000)",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Request Handling and Forms",
        "content": "Handle different HTTP methods, form data, and request parameters:",
        "code": "# Advanced request handling simulation\nimport json\nfrom urllib.parse import parse_qs\n\nclass FlaskRequest:\n    \"\"\"Simulated Flask request object\"\"\"\n    def __init__(self, method='GET', path='/', data=None, args=None):\n        self.method = method\n        self.path = path\n        self.form = data or {}\n        self.args = args or {}\n        self.json = None\n        if data and isinstance(data, dict):\n            self.json = data\n\nclass FlaskApp:\n    \"\"\"Enhanced Flask simulation with request handling\"\"\"\n    def __init__(self):\n        self.routes = {}\n        self.current_request = None\n    \n    def route(self, path, methods=['GET']):\n        def decorator(func):\n            self.routes[(path, tuple(methods))] = func\n            return func\n        return decorator\n    \n    def handle_request(self, request):\n        \"\"\"Simulate handling an HTTP request\"\"\"\n        self.current_request = request\n        \n        # Find matching route\n        for (path, methods), handler in self.routes.items():\n            if path == request.path and request.method in methods:\n                return handler()\n        \n        return \"404 Not Found\", 404\n    \n    def simulate_requests(self):\n        \"\"\"Simulate various HTTP requests\"\"\"\n        requests = [\n            FlaskRequest('GET', '/'),\n            FlaskRequest('GET', '/search', args={'q': 'python', 'page': '1'}),\n            FlaskRequest('POST', '/users', data={'name': 'Eve', 'email': 'eve@example.com'}),\n            FlaskRequest('POST', '/api/login', data={'username': 'admin', 'password': 'secret123'}),\n        ]\n        \n        for req in requests:\n            print(f\"\\n📡 {req.method} {req.path}\")\n            if req.args:\n                print(f\"   Query params: {req.args}\")\n            if req.form:\n                print(f\"   Form data: {req.form}\")\n            \n            response = self.handle_request(req)\n            if isinstance(response, tuple):\n                content, status = response\n                print(f\"📤 Response ({status}): {content}\")\n            else:\n                print(f\"📤 Response (200): {response}\")\n\n# Create app instance\napp = FlaskApp()\n\n@app.route('/', methods=['GET'])\ndef home():\n    return \"Welcome to the Python Web Development Demo!\"\n\n@app.route('/search', methods=['GET'])\ndef search():\n    # Access query parameters\n    query = app.current_request.args.get('q', '')\n    page = int(app.current_request.args.get('page', 1))\n    \n    # Simulate search results\n    if query:\n        results = [\n            f\"Python Tutorial #{i}\" for i in range((page-1)*5 + 1, page*5 + 1)\n        ]\n        return f\"Search results for '{query}' (page {page}): {', '.join(results)}\"\n    else:\n        return \"Please provide a search query\"\n\n@app.route('/users', methods=['POST'])\ndef create_user():\n    # Access form data\n    name = app.current_request.form.get('name')\n    email = app.current_request.form.get('email')\n    \n    if name and email:\n        # Simulate saving user to database\n        user_id = 12345\n        return f\"User created successfully! ID: {user_id}, Name: {name}, Email: {email}\"\n    else:\n        return \"Missing required fields: name and email\", 400\n\n@app.route('/api/login', methods=['POST'])\ndef login():\n    # Handle JSON or form data\n    username = app.current_request.form.get('username')\n    password = app.current_request.form.get('password')\n    \n    # Simple authentication simulation\n    if username == 'admin' and password == 'secret123':\n        token = f\"jwt_token_for_{username}_12345\"\n        return f\"{{\\\"status\\\": \\\"success\\\", \\\"token\\\": \\\"{token}\\\"}}\"\n    else:\n        return \"{\\\"status\\\": \\\"error\\\", \\\"message\\\": \\\"Invalid credentials\\\"}\", 401\n\n# Demonstrate the application\nprint(\"🌐 Web Development with Python - Request Handling Demo\")\nprint(\"=\" * 60)\napp.simulate_requests()",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "REST API Design",
        "content": "Build a complete REST API with proper HTTP methods and status codes:",
        "code": "# REST API Design Simulation\nimport json\nfrom datetime import datetime\n\nclass RESTAPI:\n    \"\"\"Simulated REST API for a blog system\"\"\"\n    \n    def __init__(self):\n        # In-memory database simulation\n        self.posts = {\n            1: {'id': 1, 'title': 'Getting Started with Python', 'content': 'Python is amazing...', 'author': 'Alice', 'created_at': '2024-01-01T10:00:00'},\n            2: {'id': 2, 'title': 'Web Development Basics', 'content': 'Building web apps...', 'author': 'Bob', 'created_at': '2024-01-02T11:30:00'},\n            3: {'id': 3, 'title': 'Data Science with Python', 'content': 'Analyzing data...', 'author': 'Charlie', 'created_at': '2024-01-03T09:15:00'}\n        }\n        self.next_id = 4\n        \n    def get_posts(self, author=None, limit=None):\n        \"\"\"GET /api/posts - List all posts with optional filtering\"\"\"\n        posts = list(self.posts.values())\n        \n        # Filter by author if specified\n        if author:\n            posts = [p for p in posts if p['author'].lower() == author.lower()]\n        \n        # Limit results if specified\n        if limit:\n            posts = posts[:limit]\n        \n        return {\n            'status': 'success',\n            'data': posts,\n            'total': len(posts)\n        }, 200\n    \n    def get_post(self, post_id):\n        \"\"\"GET /api/posts/<id> - Get a specific post\"\"\"\n        if post_id in self.posts:\n            return {\n                'status': 'success',\n                'data': self.posts[post_id]\n            }, 200\n        else:\n            return {\n                'status': 'error',\n                'message': f'Post {post_id} not found'\n            }, 404\n    \n    def create_post(self, data):\n        \"\"\"POST /api/posts - Create a new post\"\"\"\n        required_fields = ['title', 'content', 'author']\n        \n        # Validate required fields\n        for field in required_fields:\n            if field not in data:\n                return {\n                    'status': 'error',\n                    'message': f'Missing required field: {field}'\n                }, 400\n        \n        # Create new post\n        new_post = {\n            'id': self.next_id,\n            'title': data['title'],\n            'content': data['content'],\n            'author': data['author'],\n            'created_at': datetime.now().isoformat()\n        }\n        \n        self.posts[self.next_id] = new_post\n        self.next_id += 1\n        \n        return {\n            'status': 'success',\n            'data': new_post,\n            'message': 'Post created successfully'\n        }, 201\n    \n    def update_post(self, post_id, data):\n        \"\"\"PUT /api/posts/<id> - Update a post\"\"\"\n        if post_id not in self.posts:\n            return {\n                'status': 'error',\n                'message': f'Post {post_id} not found'\n            }, 404\n        \n        # Update post fields\n        post = self.posts[post_id]\n        updatable_fields = ['title', 'content']\n        \n        for field in updatable_fields:\n            if field in data:\n                post[field] = data[field]\n        \n        post['updated_at'] = datetime.now().isoformat()\n        \n        return {\n            'status': 'success',\n            'data': post,\n            'message': 'Post updated successfully'\n        }, 200\n    \n    def delete_post(self, post_id):\n        \"\"\"DELETE /api/posts/<id> - Delete a post\"\"\"\n        if post_id not in self.posts:\n            return {\n                'status': 'error',\n                'message': f'Post {post_id} not found'\n            }, 404\n        \n        deleted_post = self.posts.pop(post_id)\n        \n        return {\n            'status': 'success',\n            'message': f'Post {post_id} deleted successfully',\n            'data': deleted_post\n        }, 200\n\ndef simulate_api_requests():\n    \"\"\"Simulate various API requests\"\"\"\n    api = RESTAPI()\n    \n    print(\"🔌 REST API Demonstration - Blog Posts API\")\n    print(\"=\" * 50)\n    \n    # GET all posts\n    print(\"\\n1. GET /api/posts\")\n    response, status = api.get_posts()\n    print(f\"Status: {status}\")\n    print(f\"Response: Found {response['total']} posts\")\n    \n    # GET posts by author\n    print(\"\\n2. GET /api/posts?author=Alice\")\n    response, status = api.get_posts(author='Alice')\n    print(f\"Status: {status}\")\n    print(f\"Response: Found {response['total']} posts by Alice\")\n    \n    # GET specific post\n    print(\"\\n3. GET /api/posts/1\")\n    response, status = api.get_post(1)\n    print(f\"Status: {status}\")\n    if status == 200:\n        print(f\"Response: {response['data']['title']} by {response['data']['author']}\")\n    \n    # POST new post\n    print(\"\\n4. POST /api/posts\")\n    new_post_data = {\n        'title': 'Advanced Python Techniques',\n        'content': 'Decorators, context managers, and more...',\n        'author': 'Diana'\n    }\n    response, status = api.create_post(new_post_data)\n    print(f\"Status: {status}\")\n    if status == 201:\n        print(f\"Response: Created post #{response['data']['id']} - {response['data']['title']}\")\n    \n    # PUT update post\n    print(\"\\n5. PUT /api/posts/2\")\n    update_data = {\n        'title': 'Advanced Web Development with Python',\n        'content': 'Updated content with more advanced topics...'\n    }\n    response, status = api.update_post(2, update_data)\n    print(f\"Status: {status}\")\n    if status == 200:\n        print(f\"Response: Updated post - {response['data']['title']}\")\n    \n    # DELETE post\n    print(\"\\n6. DELETE /api/posts/3\")\n    response, status = api.delete_post(3)\n    print(f\"Status: {status}\")\n    if status == 200:\n        print(f\"Response: {response['message']}\")\n    \n    # GET non-existent post\n    print(\"\\n7. GET /api/posts/999\")\n    response, status = api.get_post(999)\n    print(f\"Status: {status}\")\n    if status == 404:\n        print(f\"Response: {response['message']}\")\n    \n    # Final state\n    print(\"\\n8. Final GET /api/posts (after all operations)\")\n    response, status = api.get_posts()\n    print(f\"Status: {status}\")\n    print(f\"Response: {response['total']} posts remaining\")\n    for post in response['data']:\n        print(f\"  - #{post['id']}: {post['title']} by {post['author']}\")\n\n# Run the simulation\nsimulate_api_requests()",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Simple Route Handler",
        "description": "Create a basic route handler that returns user information.",
        "starterCode": "def create_user_route(users_db):\n    def get_user(user_id):\n        # Return user info or error message\n        pass\n    return get_user\n\n# Test data\nusers = {'1': {'name': 'Alice', 'role': 'admin'}, '2': {'name': 'Bob', 'role': 'user'}}\nget_user_handler = create_user_route(users)\nprint(get_user_handler('1'))",
        "expectedOutput": "{'name': 'Alice', 'role': 'admin'}",
        "solution": "def create_user_route(users_db):\n    def get_user(user_id):\n        if user_id in users_db:\n            return users_db[user_id]\n        else:\n            return {'error': 'User not found'}\n    return get_user"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium", 
        "title": "Request Validator",
        "description": "Create a function that validates API request data.",
        "starterCode": "def validate_user_data(data, required_fields):\n    # Validate that all required fields are present and not empty\n    pass\n\n# Test\nuser_data = {'name': 'Alice', 'email': 'alice@example.com'}\nrequired = ['name', 'email', 'age']\nresult = validate_user_data(user_data, required)\nprint(result)",
        "expectedOutput": "{'valid': False, 'missing_fields': ['age']}",
        "solution": "def validate_user_data(data, required_fields):\n    missing_fields = []\n    for field in required_fields:\n        if field not in data or not data[field]:\n            missing_fields.append(field)\n    \n    return {\n        'valid': len(missing_fields) == 0,\n        'missing_fields': missing_fields\n    }"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Complete REST Resource",
        "description": "Implement a complete CRUD resource for managing tasks.",
        "starterCode": "class TaskAPI:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n    \n    def create_task(self, data):\n        # Create a new task\n        pass\n    \n    def get_task(self, task_id):\n        # Get a specific task\n        pass\n    \n    def update_task(self, task_id, data):\n        # Update a task\n        pass\n    \n    def delete_task(self, task_id):\n        # Delete a task\n        pass\n\n# Test the API\napi = TaskAPI()\nprint(api.create_task({'title': 'Learn Python', 'completed': False}))",
        "expectedOutput": "{'id': 1, 'title': 'Learn Python', 'completed': False, 'created_at': '2024-01-15T12:00:00'}",
        "solution": "from datetime import datetime\n\nclass TaskAPI:\n    def __init__(self):\n        self.tasks = {}\n        self.next_id = 1\n    \n    def create_task(self, data):\n        if 'title' not in data:\n            return {'error': 'Title is required'}\n        \n        task = {\n            'id': self.next_id,\n            'title': data['title'],\n            'completed': data.get('completed', False),\n            'created_at': datetime.now().isoformat()\n        }\n        \n        self.tasks[self.next_id] = task\n        self.next_id += 1\n        return task\n    \n    def get_task(self, task_id):\n        return self.tasks.get(task_id, {'error': 'Task not found'})\n    \n    def update_task(self, task_id, data):\n        if task_id not in self.tasks:\n            return {'error': 'Task not found'}\n        \n        task = self.tasks[task_id]\n        for key in ['title', 'completed']:\n            if key in data:\n                task[key] = data[key]\n        \n        task['updated_at'] = datetime.now().isoformat()\n        return task\n    \n    def delete_task(self, task_id):\n        if task_id in self.tasks:\n            return self.tasks.pop(task_id)\n        return {'error': 'Task not found'}"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "Which HTTP method is typically used to create a new resource?",
        "type": "multiple-choice",
        "options": ["GET", "POST", "PUT", "DELETE"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "What HTTP status code indicates a resource was successfully created?",
        "type": "multiple-choice",
        "options": ["200", "201", "204", "400"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "database-programming",
    "title": "Database Programming", 
    "description": "Learn to work with databases using SQL, ORMs, and database design principles.",
    "category": "Database Programming",
    "difficulty": "advanced",
    "estimatedTime": 40,
    "xpReward": 190,
    "prerequisites": ["python-classes", "python-dictionaries"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Database Fundamentals",
        "content": "Databases are essential for storing and retrieving data in applications. Python provides excellent tools for database programming:\n\n• SQLite: Built-in lightweight database\n• PostgreSQL: Powerful open-source database\n• MySQL: Popular relational database\n• MongoDB: NoSQL document database\n\nKey concepts:\n• CRUD operations: Create, Read, Update, Delete\n• SQL: Structured Query Language\n• Transactions: Atomic operations\n• Indexes: Performance optimization\n• Relationships: Foreign keys and joins\n• ORM: Object-Relational Mapping\n\nPython database libraries:\n• sqlite3: Built-in SQLite support\n• psycopg2: PostgreSQL adapter\n• SQLAlchemy: Popular ORM framework\n• Django ORM: Web framework ORM"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "SQLite Database Operations",
        "content": "Learn basic database operations with Python's built-in SQLite support:",
        "code": "# Simulated SQLite operations (educational purposes)\n# In real applications, you'd use the sqlite3 module\n\nclass MockDatabase:\n    \"\"\"Simulated database for educational purposes\"\"\"\n    \n    def __init__(self, db_name):\n        self.db_name = db_name\n        self.tables = {}\n        self.connections = 0\n        print(f\"📂 Created database: {db_name}\")\n    \n    def connect(self):\n        self.connections += 1\n        print(f\"🔌 Connected to {self.db_name} (connections: {self.connections})\")\n        return MockConnection(self)\n    \n    def create_table(self, table_name, schema):\n        self.tables[table_name] = {\n            'schema': schema,\n            'data': [],\n            'next_id': 1\n        }\n        print(f\"📋 Created table: {table_name}\")\n        print(f\"   Schema: {schema}\")\n\nclass MockConnection:\n    \"\"\"Simulated database connection\"\"\"\n    \n    def __init__(self, database):\n        self.database = database\n        self.closed = False\n    \n    def execute(self, query, params=None):\n        if self.closed:\n            raise Exception(\"Connection is closed\")\n        \n        print(f\"📝 Executing: {query}\")\n        if params:\n            print(f\"   Parameters: {params}\")\n        \n        return MockCursor(self.database, query, params)\n    \n    def commit(self):\n        print(\"💾 Transaction committed\")\n    \n    def rollback(self):\n        print(\"↩️  Transaction rolled back\")\n    \n    def close(self):\n        self.closed = True\n        self.database.connections -= 1\n        print(f\"🔌 Connection closed (remaining: {self.database.connections})\")\n\nclass MockCursor:\n    \"\"\"Simulated database cursor\"\"\"\n    \n    def __init__(self, database, query, params):\n        self.database = database\n        self.query = query.strip().lower()\n        self.params = params or []\n        self.results = self._execute_query()\n    \n    def _execute_query(self):\n        \"\"\"Simulate query execution\"\"\"\n        if self.query.startswith('create table'):\n            return self._handle_create_table()\n        elif self.query.startswith('insert'):\n            return self._handle_insert()\n        elif self.query.startswith('select'):\n            return self._handle_select()\n        elif self.query.startswith('update'):\n            return self._handle_update()\n        elif self.query.startswith('delete'):\n            return self._handle_delete()\n        else:\n            return []\n    \n    def _handle_create_table(self):\n        # Simplified table creation\n        return []\n    \n    def _handle_insert(self):\n        # Simulate insert operation\n        if 'users' in self.database.tables:\n            table = self.database.tables['users']\n            new_record = {\n                'id': table['next_id'],\n                'name': self.params[0] if self.params else 'Unknown',\n                'email': self.params[1] if len(self.params) > 1 else 'unknown@example.com',\n                'age': self.params[2] if len(self.params) > 2 else 0\n            }\n            table['data'].append(new_record)\n            table['next_id'] += 1\n            print(f\"   ✅ Inserted record with ID {new_record['id']}\")\n            return [new_record['id']]\n        return []\n    \n    def _handle_select(self):\n        # Simulate select operation\n        if 'users' in self.database.tables:\n            data = self.database.tables['users']['data']\n            print(f\"   📊 Found {len(data)} records\")\n            return data\n        return []\n    \n    def _handle_update(self):\n        # Simulate update operation\n        if 'users' in self.database.tables and self.params:\n            table = self.database.tables['users']\n            updated_count = 0\n            for record in table['data']:\n                if record['id'] == self.params[-1]:  # Assuming last param is ID\n                    if len(self.params) >= 2:\n                        record['name'] = self.params[0]\n                    if len(self.params) >= 3:\n                        record['email'] = self.params[1]\n                    updated_count += 1\n                    break\n            print(f\"   ✅ Updated {updated_count} record(s)\")\n            return [updated_count]\n        return [0]\n    \n    def _handle_delete(self):\n        # Simulate delete operation\n        if 'users' in self.database.tables and self.params:\n            table = self.database.tables['users']\n            original_count = len(table['data'])\n            table['data'] = [r for r in table['data'] if r['id'] != self.params[0]]\n            deleted_count = original_count - len(table['data'])\n            print(f\"   ✅ Deleted {deleted_count} record(s)\")\n            return [deleted_count]\n        return [0]\n    \n    def fetchall(self):\n        return self.results\n    \n    def fetchone(self):\n        return self.results[0] if self.results else None\n    \n    def fetchmany(self, size=1):\n        return self.results[:size]\n\ndef demonstrate_database_operations():\n    \"\"\"Demonstrate basic database operations\"\"\"\n    print(\"🗄️  Database Programming Demonstration\")\n    print(\"=\" * 45)\n    \n    # Create database and table\n    db = MockDatabase(\"users.db\")\n    db.create_table(\"users\", {\n        'id': 'INTEGER PRIMARY KEY',\n        'name': 'TEXT NOT NULL',\n        'email': 'TEXT UNIQUE',\n        'age': 'INTEGER'\n    })\n    \n    # Connect to database\n    conn = db.connect()\n    \n    try:\n        # Insert users\n        print(\"\\n1. Inserting Users:\")\n        users_to_insert = [\n            ('Alice Johnson', 'alice@example.com', 28),\n            ('Bob Smith', 'bob@example.com', 32),\n            ('Charlie Brown', 'charlie@example.com', 25),\n            ('Diana Prince', 'diana@example.com', 30)\n        ]\n        \n        for user_data in users_to_insert:\n            cursor = conn.execute(\n                \"INSERT INTO users (name, email, age) VALUES (?, ?, ?)\",\n                user_data\n            )\n        \n        conn.commit()\n        \n        # Select all users\n        print(\"\\n2. Selecting All Users:\")\n        cursor = conn.execute(\"SELECT * FROM users\")\n        users = cursor.fetchall()\n        for user in users:\n            print(f\"   👤 ID: {user['id']}, Name: {user['name']}, Email: {user['email']}, Age: {user['age']}\")\n        \n        # Update a user\n        print(\"\\n3. Updating User:\")\n        conn.execute(\n            \"UPDATE users SET name = ?, email = ? WHERE id = ?\",\n            ('Alice Cooper', 'alice.cooper@example.com', 1)\n        )\n        conn.commit()\n        \n        # Select updated user\n        cursor = conn.execute(\"SELECT * FROM users WHERE id = ?\", [1])\n        updated_user = cursor.fetchone()\n        if updated_user:\n            print(f\"   ✅ Updated user: {updated_user['name']} ({updated_user['email']})\")\n        \n        # Delete a user\n        print(\"\\n4. Deleting User:\")\n        conn.execute(\"DELETE FROM users WHERE id = ?\", [3])\n        conn.commit()\n        \n        # Final count\n        cursor = conn.execute(\"SELECT * FROM users\")\n        remaining_users = cursor.fetchall()\n        print(f\"   📊 Remaining users: {len(remaining_users)}\")\n        \n    except Exception as e:\n        print(f\"❌ Error: {e}\")\n        conn.rollback()\n    \n    finally:\n        conn.close()\n        print(\"\\n🎯 Database operations completed successfully!\")\n\n# Run the demonstration\ndemonstrate_database_operations()",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "ORM Concepts and Implementation",
        "content": "Learn Object-Relational Mapping with a simple ORM implementation:",
        "code": "# Simple ORM implementation for educational purposes\nfrom datetime import datetime\nfrom typing import Dict, List, Any, Optional\n\nclass Field:\n    \"\"\"Base field class for ORM models\"\"\"\n    def __init__(self, field_type: str, required: bool = True, unique: bool = False):\n        self.field_type = field_type\n        self.required = required\n        self.unique = unique\n        self.name = None  # Set by metaclass\n    \n    def validate(self, value: Any) -> bool:\n        if self.required and value is None:\n            return False\n        return True\n\nclass CharField(Field):\n    def __init__(self, max_length: int = 255, **kwargs):\n        super().__init__('TEXT', **kwargs)\n        self.max_length = max_length\n    \n    def validate(self, value: Any) -> bool:\n        if not super().validate(value):\n            return False\n        if value and len(str(value)) > self.max_length:\n            return False\n        return True\n\nclass IntegerField(Field):\n    def __init__(self, **kwargs):\n        super().__init__('INTEGER', **kwargs)\n    \n    def validate(self, value: Any) -> bool:\n        if not super().validate(value):\n            return False\n        if value is not None and not isinstance(value, int):\n            return False\n        return True\n\nclass DateTimeField(Field):\n    def __init__(self, auto_now: bool = False, **kwargs):\n        super().__init__('DATETIME', **kwargs)\n        self.auto_now = auto_now\n    \n    def get_default(self):\n        if self.auto_now:\n            return datetime.now()\n        return None\n\nclass ModelMeta(type):\n    \"\"\"Metaclass for ORM models\"\"\"\n    def __new__(cls, name, bases, attrs):\n        # Extract fields from class attributes\n        fields = {}\n        for key, value in list(attrs.items()):\n            if isinstance(value, Field):\n                value.name = key\n                fields[key] = value\n                attrs.pop(key)  # Remove from class attributes\n        \n        attrs['_fields'] = fields\n        attrs['_table_name'] = name.lower() + 's'\n        \n        return super().__new__(cls, name, bases, attrs)\n\nclass Model(metaclass=ModelMeta):\n    \"\"\"Base ORM model class\"\"\"\n    \n    def __init__(self, **kwargs):\n        self._data = {}\n        self._original_data = {}\n        \n        # Set field values\n        for field_name, field in self._fields.items():\n            if field_name in kwargs:\n                value = kwargs[field_name]\n            elif hasattr(field, 'get_default'):\n                value = field.get_default()\n            else:\n                value = None\n            \n            self._data[field_name] = value\n            self._original_data[field_name] = value\n    \n    def __getattr__(self, name):\n        if name in self._fields:\n            return self._data.get(name)\n        raise AttributeError(f\"'{self.__class__.__name__}' has no attribute '{name}'\")\n    \n    def __setattr__(self, name, value):\n        if name.startswith('_') or name not in self._fields:\n            super().__setattr__(name, value)\n        else:\n            self._data[name] = value\n    \n    def validate(self) -> List[str]:\n        \"\"\"Validate all fields and return list of errors\"\"\"\n        errors = []\n        for field_name, field in self._fields.items():\n            value = self._data.get(field_name)\n            if not field.validate(value):\n                errors.append(f\"Validation failed for field '{field_name}'\")\n        return errors\n    \n    def save(self) -> bool:\n        \"\"\"Save the model instance\"\"\"\n        errors = self.validate()\n        if errors:\n            print(f\"❌ Validation errors: {', '.join(errors)}\")\n            return False\n        \n        if hasattr(self, 'id') and self.id:\n            # Update existing record\n            print(f\"💾 Updating {self.__class__.__name__} with ID {self.id}\")\n            self._update_record()\n        else:\n            # Create new record\n            print(f\"✨ Creating new {self.__class__.__name__}\")\n            self._create_record()\n        \n        # Update original data\n        self._original_data = self._data.copy()\n        return True\n    \n    def _create_record(self):\n        \"\"\"Simulate creating a new database record\"\"\"\n        # In a real ORM, this would generate SQL INSERT\n        if not hasattr(self.__class__, '_next_id'):\n            self.__class__._next_id = 1\n        \n        self._data['id'] = self.__class__._next_id\n        self.__class__._next_id += 1\n        \n        # Add to class-level storage (simulating database)\n        if not hasattr(self.__class__, '_records'):\n            self.__class__._records = []\n        \n        self.__class__._records.append(self._data.copy())\n        print(f\"   📝 Assigned ID: {self.id}\")\n    \n    def _update_record(self):\n        \"\"\"Simulate updating an existing database record\"\"\"\n        # In a real ORM, this would generate SQL UPDATE\n        if hasattr(self.__class__, '_records'):\n            for i, record in enumerate(self.__class__._records):\n                if record.get('id') == self.id:\n                    self.__class__._records[i] = self._data.copy()\n                    break\n    \n    @classmethod\n    def all(cls):\n        \"\"\"Get all records for this model\"\"\"\n        if not hasattr(cls, '_records'):\n            return []\n        \n        instances = []\n        for record_data in cls._records:\n            instance = cls(**record_data)\n            instances.append(instance)\n        \n        return instances\n    \n    @classmethod\n    def filter(cls, **kwargs):\n        \"\"\"Filter records by field values\"\"\"\n        all_records = cls.all()\n        filtered = []\n        \n        for record in all_records:\n            match = True\n            for field, value in kwargs.items():\n                if getattr(record, field, None) != value:\n                    match = False\n                    break\n            if match:\n                filtered.append(record)\n        \n        return filtered\n    \n    def __repr__(self):\n        return f\"<{self.__class__.__name__}: {self._data}>\"\n\n# Define models using the ORM\nclass User(Model):\n    name = CharField(max_length=100)\n    email = CharField(max_length=150, unique=True)\n    age = IntegerField(required=False)\n    created_at = DateTimeField(auto_now=True)\n\nclass Post(Model):\n    title = CharField(max_length=200)\n    content = CharField(max_length=1000)\n    author_id = IntegerField()\n    created_at = DateTimeField(auto_now=True)\n\ndef demonstrate_orm():\n    \"\"\"Demonstrate ORM functionality\"\"\"\n    print(\"🏗️  ORM (Object-Relational Mapping) Demonstration\")\n    print(\"=\" * 50)\n    \n    # Create users\n    print(\"\\n1. Creating Users:\")\n    users_data = [\n        {'name': 'Alice Johnson', 'email': 'alice@example.com', 'age': 28},\n        {'name': 'Bob Smith', 'email': 'bob@example.com', 'age': 32},\n        {'name': 'Charlie Brown', 'email': 'charlie@example.com', 'age': 25}\n    ]\n    \n    users = []\n    for user_data in users_data:\n        user = User(**user_data)\n        if user.save():\n            users.append(user)\n            print(f\"   ✅ Created user: {user.name} (ID: {user.id})\")\n    \n    # Create posts\n    print(\"\\n2. Creating Posts:\")\n    posts_data = [\n        {'title': 'Getting Started with Python', 'content': 'Python is an amazing language...', 'author_id': 1},\n        {'title': 'Web Development Tips', 'content': 'Building great web applications...', 'author_id': 1},\n        {'title': 'Database Design Patterns', 'content': 'Effective database design...', 'author_id': 2}\n    ]\n    \n    posts = []\n    for post_data in posts_data:\n        post = Post(**post_data)\n        if post.save():\n            posts.append(post)\n            print(f\"   ✅ Created post: {post.title} (ID: {post.id})\")\n    \n    # Query all users\n    print(\"\\n3. Querying All Users:\")\n    all_users = User.all()\n    for user in all_users:\n        print(f\"   👤 {user.name} ({user.email}) - Age: {user.age}\")\n    \n    # Filter posts by author\n    print(\"\\n4. Filtering Posts by Author:\")\n    alice_posts = Post.filter(author_id=1)\n    print(f\"   📝 Alice's posts ({len(alice_posts)}):\")\n    for post in alice_posts:\n        print(f\"      - {post.title}\")\n    \n    # Update a user\n    print(\"\\n5. Updating User:\")\n    if users:\n        user_to_update = users[0]\n        user_to_update.age = 29\n        user_to_update.email = 'alice.johnson@example.com'\n        if user_to_update.save():\n            print(f\"   ✅ Updated {user_to_update.name}: age={user_to_update.age}, email={user_to_update.email}\")\n    \n    print(\"\\n🎯 ORM demonstration completed successfully!\")\n\n# Run the demonstration\ndemonstrate_orm()",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Database Design and Relationships",
        "content": "Learn database design principles and handling relationships:",
        "code": "# Database design and relationships demonstration\nfrom typing import List, Optional, Dict, Any\nfrom datetime import datetime, date\n\nclass DatabaseSchema:\n    \"\"\"Represents a database schema with tables and relationships\"\"\"\n    \n    def __init__(self):\n        self.tables = {}\n        self.relationships = []\n    \n    def create_table(self, name: str, columns: Dict[str, str], primary_key: str = 'id'):\n        \"\"\"Create a table schema\"\"\"\n        self.tables[name] = {\n            'columns': columns,\n            'primary_key': primary_key,\n            'foreign_keys': [],\n            'indexes': []\n        }\n        print(f\"📋 Created table '{name}' with columns: {list(columns.keys())}\")\n    \n    def add_foreign_key(self, table: str, column: str, references_table: str, references_column: str = 'id'):\n        \"\"\"Add a foreign key relationship\"\"\"\n        if table in self.tables:\n            fk = {\n                'column': column,\n                'references_table': references_table,\n                'references_column': references_column\n            }\n            self.tables[table]['foreign_keys'].append(fk)\n            self.relationships.append({\n                'from': f\"{table}.{column}\",\n                'to': f\"{references_table}.{references_column}\",\n                'type': 'foreign_key'\n            })\n            print(f\"🔗 Added foreign key: {table}.{column} -> {references_table}.{references_column}\")\n    \n    def add_index(self, table: str, columns: List[str], unique: bool = False):\n        \"\"\"Add an index to improve query performance\"\"\"\n        if table in self.tables:\n            index = {\n                'columns': columns,\n                'unique': unique\n            }\n            self.tables[table]['indexes'].append(index)\n            index_type = \"unique\" if unique else \"regular\"\n            print(f\"📊 Added {index_type} index on {table}({', '.join(columns)})\")\n    \n    def print_schema(self):\n        \"\"\"Print the complete database schema\"\"\"\n        print(\"\\n📊 Database Schema:\")\n        print(\"=\" * 30)\n        \n        for table_name, table_info in self.tables.items():\n            print(f\"\\n🏷️  Table: {table_name}\")\n            print(f\"   Primary Key: {table_info['primary_key']}\")\n            print(\"   Columns:\")\n            for col_name, col_type in table_info['columns'].items():\n                marker = \" (PK)\" if col_name == table_info['primary_key'] else \"\"\n                print(f\"      - {col_name}: {col_type}{marker}\")\n            \n            if table_info['foreign_keys']:\n                print(\"   Foreign Keys:\")\n                for fk in table_info['foreign_keys']:\n                    print(f\"      - {fk['column']} -> {fk['references_table']}.{fk['references_column']}\")\n            \n            if table_info['indexes']:\n                print(\"   Indexes:\")\n                for idx in table_info['indexes']:\n                    idx_type = \"UNIQUE\" if idx['unique'] else \"INDEX\"\n                    print(f\"      - {idx_type} ({', '.join(idx['columns'])})\")\n\nclass QueryBuilder:\n    \"\"\"Simple SQL query builder for educational purposes\"\"\"\n    \n    def __init__(self, table: str):\n        self.table = table\n        self.select_columns = ['*']\n        self.where_conditions = []\n        self.joins = []\n        self.order_by_columns = []\n        self.limit_count = None\n    \n    def select(self, *columns):\n        \"\"\"Specify columns to select\"\"\"\n        self.select_columns = list(columns) if columns else ['*']\n        return self\n    \n    def where(self, condition: str, value: Any = None):\n        \"\"\"Add WHERE condition\"\"\"\n        self.where_conditions.append({'condition': condition, 'value': value})\n        return self\n    \n    def join(self, table: str, on_condition: str, join_type: str = 'INNER'):\n        \"\"\"Add JOIN clause\"\"\"\n        self.joins.append({\n            'table': table,\n            'condition': on_condition,\n            'type': join_type\n        })\n        return self\n    \n    def order_by(self, column: str, direction: str = 'ASC'):\n        \"\"\"Add ORDER BY clause\"\"\"\n        self.order_by_columns.append(f\"{column} {direction}\")\n        return self\n    \n    def limit(self, count: int):\n        \"\"\"Add LIMIT clause\"\"\"\n        self.limit_count = count\n        return self\n    \n    def build(self) -> str:\n        \"\"\"Build the SQL query string\"\"\"\n        # SELECT clause\n        query = f\"SELECT {', '.join(self.select_columns)}\\nFROM {self.table}\"\n        \n        # JOIN clauses\n        for join in self.joins:\n            query += f\"\\n{join['type']} JOIN {join['table']} ON {join['condition']}\"\n        \n        # WHERE clause\n        if self.where_conditions:\n            conditions = []\n            for cond in self.where_conditions:\n                if cond['value'] is not None:\n                    conditions.append(f\"{cond['condition']} = '{cond['value']}'\")\n                else:\n                    conditions.append(cond['condition'])\n            query += f\"\\nWHERE {' AND '.join(conditions)}\"\n        \n        # ORDER BY clause\n        if self.order_by_columns:\n            query += f\"\\nORDER BY {', '.join(self.order_by_columns)}\"\n        \n        # LIMIT clause\n        if self.limit_count:\n            query += f\"\\nLIMIT {self.limit_count}\"\n        \n        return query\n\ndef demonstrate_database_design():\n    \"\"\"Demonstrate database design principles\"\"\"\n    print(\"🗂️  Database Design and Relationships\")\n    print(\"=\" * 45)\n    \n    # Create a schema for a blog application\n    schema = DatabaseSchema()\n    \n    # Users table\n    schema.create_table('users', {\n        'id': 'INTEGER PRIMARY KEY AUTOINCREMENT',\n        'username': 'VARCHAR(50) UNIQUE NOT NULL',\n        'email': 'VARCHAR(100) UNIQUE NOT NULL',\n        'password_hash': 'VARCHAR(255) NOT NULL',\n        'first_name': 'VARCHAR(50)',\n        'last_name': 'VARCHAR(50)',\n        'created_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP',\n        'updated_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP'\n    })\n    \n    # Categories table\n    schema.create_table('categories', {\n        'id': 'INTEGER PRIMARY KEY AUTOINCREMENT',\n        'name': 'VARCHAR(100) UNIQUE NOT NULL',\n        'description': 'TEXT',\n        'created_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP'\n    })\n    \n    # Posts table\n    schema.create_table('posts', {\n        'id': 'INTEGER PRIMARY KEY AUTOINCREMENT',\n        'title': 'VARCHAR(200) NOT NULL',\n        'slug': 'VARCHAR(200) UNIQUE NOT NULL',\n        'content': 'TEXT NOT NULL',\n        'excerpt': 'VARCHAR(500)',\n        'author_id': 'INTEGER NOT NULL',\n        'category_id': 'INTEGER NOT NULL',\n        'status': 'VARCHAR(20) DEFAULT \"draft\"',\n        'published_at': 'TIMESTAMP',\n        'created_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP',\n        'updated_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP'\n    })\n    \n    # Comments table\n    schema.create_table('comments', {\n        'id': 'INTEGER PRIMARY KEY AUTOINCREMENT',\n        'post_id': 'INTEGER NOT NULL',\n        'author_id': 'INTEGER',\n        'author_name': 'VARCHAR(100)',\n        'author_email': 'VARCHAR(100)',\n        'content': 'TEXT NOT NULL',\n        'status': 'VARCHAR(20) DEFAULT \"pending\"',\n        'created_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP'\n    })\n    \n    # Tags table (many-to-many relationship)\n    schema.create_table('tags', {\n        'id': 'INTEGER PRIMARY KEY AUTOINCREMENT',\n        'name': 'VARCHAR(50) UNIQUE NOT NULL',\n        'created_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP'\n    })\n    \n    # Post-tags junction table\n    schema.create_table('post_tags', {\n        'post_id': 'INTEGER NOT NULL',\n        'tag_id': 'INTEGER NOT NULL',\n        'created_at': 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP'\n    }, primary_key='post_id,tag_id')\n    \n    # Add foreign key relationships\n    schema.add_foreign_key('posts', 'author_id', 'users')\n    schema.add_foreign_key('posts', 'category_id', 'categories')\n    schema.add_foreign_key('comments', 'post_id', 'posts')\n    schema.add_foreign_key('comments', 'author_id', 'users')\n    schema.add_foreign_key('post_tags', 'post_id', 'posts')\n    schema.add_foreign_key('post_tags', 'tag_id', 'tags')\n    \n    # Add indexes for performance\n    schema.add_index('users', ['email'], unique=True)\n    schema.add_index('users', ['username'], unique=True)\n    schema.add_index('posts', ['slug'], unique=True)\n    schema.add_index('posts', ['author_id'])\n    schema.add_index('posts', ['category_id'])\n    schema.add_index('posts', ['published_at'])\n    schema.add_index('comments', ['post_id'])\n    schema.add_index('comments', ['author_id'])\n    \n    # Print the complete schema\n    schema.print_schema()\n    \n    # Demonstrate query building\n    print(\"\\n🔍 Query Examples:\")\n    print(\"=\" * 20)\n    \n    # Query 1: Get all published posts with author info\n    query1 = QueryBuilder('posts') \\\n        .select('posts.title', 'posts.excerpt', 'users.username', 'posts.published_at') \\\n        .join('users', 'posts.author_id = users.id') \\\n        .where('posts.status', 'published') \\\n        .order_by('posts.published_at', 'DESC') \\\n        .limit(10) \\\n        .build()\n    \n    print(\"\\n📝 Query 1: Recent published posts with authors\")\n    print(query1)\n    \n    # Query 2: Get post with comments and category\n    query2 = QueryBuilder('posts') \\\n        .select('posts.title', 'categories.name as category', 'COUNT(comments.id) as comment_count') \\\n        .join('categories', 'posts.category_id = categories.id') \\\n        .join('comments', 'posts.id = comments.post_id', 'LEFT') \\\n        .where('posts.id', 123) \\\n        .build()\n    \n    print(\"\\n📝 Query 2: Post with category and comment count\")\n    print(query2)\n    \n    # Query 3: Get posts by tag\n    query3 = QueryBuilder('posts') \\\n        .select('posts.title', 'posts.slug') \\\n        .join('post_tags', 'posts.id = post_tags.post_id') \\\n        .join('tags', 'post_tags.tag_id = tags.id') \\\n        .where('tags.name', 'python') \\\n        .where('posts.status', 'published') \\\n        .order_by('posts.published_at', 'DESC') \\\n        .build()\n    \n    print(\"\\n📝 Query 3: Posts tagged with 'python'\")\n    print(query3)\n    \n    print(\"\\n🎯 Database design demonstration completed!\")\n\n# Run the demonstration\ndemonstrate_database_design()",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Simple Database Query",
        "description": "Write a function to simulate a simple database query.",
        "starterCode": "def find_users_by_age(users, min_age, max_age):\n    # Return users within the age range\n    pass\n\n# Test data\nusers = [\n    {'id': 1, 'name': 'Alice', 'age': 25},\n    {'id': 2, 'name': 'Bob', 'age': 30},\n    {'id': 3, 'name': 'Charlie', 'age': 35}\n]\n\nresult = find_users_by_age(users, 25, 30)\nprint(result)",
        "expectedOutput": "[{'id': 1, 'name': 'Alice', 'age': 25}, {'id': 2, 'name': 'Bob', 'age': 30}]",
        "solution": "def find_users_by_age(users, min_age, max_age):\n    return [user for user in users if min_age <= user['age'] <= max_age]"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Database Transaction Simulation",
        "description": "Implement a simple transaction system with rollback capability.",
        "starterCode": "class SimpleTransaction:\n    def __init__(self, data):\n        self.data = data\n        self.backup = None\n    \n    def begin_transaction(self):\n        # Create backup of current data\n        pass\n    \n    def update_record(self, record_id, updates):\n        # Update a record\n        pass\n    \n    def commit(self):\n        # Finalize changes\n        pass\n    \n    def rollback(self):\n        # Restore from backup\n        pass\n\n# Test\ndata = {'users': [{'id': 1, 'name': 'Alice', 'balance': 100}]}\ntx = SimpleTransaction(data)\ntx.begin_transaction()\ntx.update_record(1, {'balance': 50})\nprint('After update:', tx.data)\ntx.rollback()\nprint('After rollback:', tx.data)",
        "expectedOutput": "After update: {'users': [{'id': 1, 'name': 'Alice', 'balance': 50}]}\nAfter rollback: {'users': [{'id': 1, 'name': 'Alice', 'balance': 100}]}",
        "solution": "import copy\n\nclass SimpleTransaction:\n    def __init__(self, data):\n        self.data = data\n        self.backup = None\n    \n    def begin_transaction(self):\n        self.backup = copy.deepcopy(self.data)\n    \n    def update_record(self, record_id, updates):\n        for user in self.data['users']:\n            if user['id'] == record_id:\n                user.update(updates)\n                break\n    \n    def commit(self):\n        self.backup = None\n    \n    def rollback(self):\n        if self.backup:\n            self.data = self.backup\n            self.backup = None"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Query Optimizer",
        "description": "Build a simple query optimization system that suggests better queries.",
        "starterCode": "class QueryOptimizer:\n    def __init__(self):\n        self.indexes = {}\n    \n    def add_index(self, table, column):\n        # Add index information\n        pass\n    \n    def analyze_query(self, query_info):\n        # Analyze and suggest optimizations\n        pass\n    \n    def estimate_cost(self, query_info):\n        # Estimate query execution cost\n        pass\n\n# Test\noptimizer = QueryOptimizer()\noptimizer.add_index('users', 'email')\nquery = {'table': 'users', 'where': ['email = \"alice@example.com\"'], 'select': ['*']}\nprint(optimizer.analyze_query(query))",
        "expectedOutput": "{'optimizations': ['Use index on email column'], 'estimated_cost': 'low', 'suggestions': ['Consider selecting only needed columns']}",
        "solution": "class QueryOptimizer:\n    def __init__(self):\n        self.indexes = {}\n    \n    def add_index(self, table, column):\n        if table not in self.indexes:\n            self.indexes[table] = []\n        self.indexes[table].append(column)\n    \n    def analyze_query(self, query_info):\n        optimizations = []\n        suggestions = []\n        \n        table = query_info['table']\n        where_clauses = query_info.get('where', [])\n        select_cols = query_info.get('select', [])\n        \n        # Check for index usage\n        for where_clause in where_clauses:\n            for column in self.indexes.get(table, []):\n                if column in where_clause:\n                    optimizations.append(f'Use index on {column} column')\n        \n        # Check SELECT *\n        if '*' in select_cols:\n            suggestions.append('Consider selecting only needed columns')\n        \n        # Estimate cost\n        cost = 'low' if optimizations else 'high'\n        \n        return {\n            'optimizations': optimizations,\n            'estimated_cost': cost,\n            'suggestions': suggestions\n        }"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What does CRUD stand for in database operations?",
        "type": "multiple-choice",
        "options": ["Create, Read, Update, Delete", "Connect, Retrieve, Upload, Download", "Copy, Restore, Undo, Deploy", "Call, Return, Use, Debug"],
        "correctAnswer": 0
      },
      {
        "id": "q2",
        "question": "What is the purpose of database indexes?",
        "type": "multiple-choice",
        "options": ["To store data", "To improve query performance", "To create relationships", "To backup data"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "algorithms-sorting",
    "title": "Sorting Algorithms Deep Dive",
    "description": "Master advanced sorting algorithms with time complexity analysis and competitive programming challenges.",
    "category": "Algorithms",
    "difficulty": "advanced",
    "estimatedTime": 45,
    "xpReward": 200,
    "prerequisites": ["algorithms-intro"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Advanced Sorting Algorithms",
        "content": "Beyond basic sorting, advanced algorithms offer better performance and unique properties for competitive programming:\n\n• Quick Sort: Average O(n log n), worst O(n²)\n• Merge Sort: Guaranteed O(n log n), stable\n• Heap Sort: O(n log n), in-place\n• Counting Sort: O(n + k) for specific ranges\n• Radix Sort: O(d × n) for fixed-width numbers\n• Tim Sort: Python's built-in, hybrid stable sort\n\nCompetitive Programming Applications:\n• Custom sorting with lambda functions\n• Sorting by multiple criteria\n• External sorting for large datasets\n• Stability requirements for equal elements"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Quick Sort Implementation",
        "content": "Implement Quick Sort with different pivot strategies:",
        "code": "import random\nfrom typing import List\n\ndef quicksort_basic(arr: List[int]) -> List[int]:\n    \"\"\"Basic quicksort implementation\"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    \n    return quicksort_basic(left) + middle + quicksort_basic(right)\n\ndef quicksort_inplace(arr: List[int], low: int = 0, high: int = None) -> None:\n    \"\"\"In-place quicksort with better space complexity\"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Partition and get pivot index\n        pivot_index = partition(arr, low, high)\n        \n        # Recursively sort left and right subarrays\n        quicksort_inplace(arr, low, pivot_index - 1)\n        quicksort_inplace(arr, pivot_index + 1, high)\n\ndef partition(arr: List[int], low: int, high: int) -> int:\n    \"\"\"Lomuto partition scheme\"\"\"\n    # Choose rightmost element as pivot\n    pivot = arr[high]\n    \n    # Index of smaller element\n    i = low - 1\n    \n    for j in range(low, high):\n        if arr[j] <= pivot:\n            i += 1\n            arr[i], arr[j] = arr[j], arr[i]\n    \n    # Place pivot in correct position\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n    return i + 1\n\ndef quicksort_randomized(arr: List[int], low: int = 0, high: int = None) -> None:\n    \"\"\"Randomized quicksort to avoid worst-case O(n²)\"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        # Randomize pivot to improve average case\n        random_index = random.randint(low, high)\n        arr[random_index], arr[high] = arr[high], arr[random_index]\n        \n        pivot_index = partition(arr, low, high)\n        quicksort_randomized(arr, low, pivot_index - 1)\n        quicksort_randomized(arr, pivot_index + 1, high)\n\ndef three_way_quicksort(arr: List[int], low: int = 0, high: int = None) -> None:\n    \"\"\"3-way quicksort for arrays with many duplicates\"\"\"\n    if high is None:\n        high = len(arr) - 1\n    \n    if low < high:\n        lt, gt = three_way_partition(arr, low, high)\n        three_way_quicksort(arr, low, lt - 1)\n        three_way_quicksort(arr, gt + 1, high)\n\ndef three_way_partition(arr: List[int], low: int, high: int) -> tuple:\n    \"\"\"Dutch National Flag partitioning\"\"\"\n    pivot = arr[low]\n    i = low\n    lt = low\n    gt = high\n    \n    while i <= gt:\n        if arr[i] < pivot:\n            arr[lt], arr[i] = arr[i], arr[lt]\n            lt += 1\n            i += 1\n        elif arr[i] > pivot:\n            arr[i], arr[gt] = arr[gt], arr[i]\n            gt -= 1\n        else:\n            i += 1\n    \n    return lt, gt\n\n# Performance comparison\nimport time\n\ndef benchmark_sorting(arr_size: int = 10000):\n    \"\"\"Compare different quicksort implementations\"\"\"\n    # Generate test data\n    original = [random.randint(1, 1000) for _ in range(arr_size)]\n    \n    algorithms = [\n        (\"Basic QuickSort\", lambda arr: quicksort_basic(arr.copy())),\n        (\"In-place QuickSort\", lambda arr: quicksort_inplace(arr.copy())),\n        (\"Randomized QuickSort\", lambda arr: quicksort_randomized(arr.copy())),\n        (\"3-way QuickSort\", lambda arr: three_way_quicksort(arr.copy())),\n        (\"Python Built-in\", lambda arr: sorted(arr))\n    ]\n    \n    print(f\"Benchmarking sorting algorithms with {arr_size} elements:\")\n    print(\"-\" * 50)\n    \n    for name, sort_func in algorithms:\n        test_arr = original.copy()\n        start_time = time.time()\n        \n        try:\n            if name == \"Basic QuickSort\" or name == \"Python Built-in\":\n                result = sort_func(test_arr)\n            else:\n                sort_func(test_arr)\n                result = test_arr\n            \n            end_time = time.time()\n            duration = (end_time - start_time) * 1000  # Convert to milliseconds\n            \n            # Verify correctness\n            is_sorted = all(result[i] <= result[i+1] for i in range(len(result)-1))\n            status = \"✓\" if is_sorted else \"✗\"\n            \n            print(f\"{name:<20} {status} {duration:6.2f}ms\")\n            \n        except RecursionError:\n            print(f\"{name:<20} ✗ Stack overflow (recursion limit)\")\n\n# Test the implementations\nprint(\"🔢 Advanced Sorting Algorithms\")\nprint(\"=\" * 35)\n\n# Test with small array\ntest_data = [64, 34, 25, 12, 22, 11, 90, 5]\nprint(f\"Original array: {test_data}\")\n\n# Test basic quicksort\nresult1 = quicksort_basic(test_data.copy())\nprint(f\"Basic QuickSort: {result1}\")\n\n# Test in-place quicksort\ntest_copy = test_data.copy()\nquicksort_inplace(test_copy)\nprint(f\"In-place QuickSort: {test_copy}\")\n\n# Test with duplicates\nduplicates = [5, 2, 8, 2, 9, 1, 5, 5, 2, 8]\nprint(f\"\\nArray with duplicates: {duplicates}\")\ntest_copy = duplicates.copy()\nthree_way_quicksort(test_copy)\nprint(f\"3-way QuickSort: {test_copy}\")\n\n# Run benchmark\nprint()\nbenchmark_sorting(1000)",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Merge Sort and External Sorting",
        "content": "Implement merge sort and learn external sorting techniques:",
        "code": "from typing import List, Iterator\nimport tempfile\nimport os\n\ndef merge_sort(arr: List[int]) -> List[int]:\n    \"\"\"Classic merge sort implementation\"\"\"\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left: List[int], right: List[int]) -> List[int]:\n    \"\"\"Merge two sorted arrays\"\"\"\n    result = []\n    i = j = 0\n    \n    # Merge while both arrays have elements\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    # Add remaining elements\n    result.extend(left[i:])\n    result.extend(right[j:])\n    \n    return result\n\ndef merge_sort_inplace(arr: List[int], temp: List[int] = None) -> None:\n    \"\"\"In-place merge sort with auxiliary array\"\"\"\n    if temp is None:\n        temp = [0] * len(arr)\n    \n    if len(arr) > 1:\n        mid = len(arr) // 2\n        \n        # Recursively sort left and right halves\n        merge_sort_inplace(arr[:mid], temp[:mid])\n        merge_sort_inplace(arr[mid:], temp[mid:])\n        \n        # Merge the sorted halves\n        merge_inplace(arr, temp, 0, mid, len(arr))\n\ndef merge_inplace(arr: List[int], temp: List[int], left: int, mid: int, right: int) -> None:\n    \"\"\"In-place merge operation\"\"\"\n    # Copy to temporary array\n    for i in range(left, right):\n        temp[i] = arr[i]\n    \n    i, j, k = left, mid, left\n    \n    # Merge back to original array\n    while i < mid and j < right:\n        if temp[i] <= temp[j]:\n            arr[k] = temp[i]\n            i += 1\n        else:\n            arr[k] = temp[j]\n            j += 1\n        k += 1\n    \n    # Copy remaining elements\n    while i < mid:\n        arr[k] = temp[i]\n        i += 1\n        k += 1\n    \n    while j < right:\n        arr[k] = temp[j]\n        j += 1\n        k += 1\n\ndef k_way_merge(arrays: List[List[int]]) -> List[int]:\n    \"\"\"Merge k sorted arrays efficiently\"\"\"\n    import heapq\n    \n    # Use min-heap for efficient k-way merge\n    heap = []\n    result = []\n    \n    # Initialize heap with first element from each array\n    for i, arr in enumerate(arrays):\n        if arr:  # Check if array is not empty\n            heapq.heappush(heap, (arr[0], i, 0))  # (value, array_index, element_index)\n    \n    while heap:\n        value, array_idx, element_idx = heapq.heappop(heap)\n        result.append(value)\n        \n        # Add next element from the same array\n        if element_idx + 1 < len(arrays[array_idx]):\n            next_value = arrays[array_idx][element_idx + 1]\n            heapq.heappush(heap, (next_value, array_idx, element_idx + 1))\n    \n    return result\n\ndef external_sort_simulation(data: List[int], chunk_size: int = 100) -> List[int]:\n    \"\"\"Simulate external sorting for large datasets\"\"\"\n    print(f\"External sorting {len(data)} elements with chunk size {chunk_size}\")\n    \n    # Step 1: Divide data into chunks and sort each\n    sorted_chunks = []\n    for i in range(0, len(data), chunk_size):\n        chunk = data[i:i + chunk_size]\n        chunk.sort()  # Sort chunk in memory\n        sorted_chunks.append(chunk)\n        print(f\"Sorted chunk {len(sorted_chunks)}: {len(chunk)} elements\")\n    \n    # Step 2: Merge all sorted chunks\n    print(f\"Merging {len(sorted_chunks)} sorted chunks...\")\n    result = k_way_merge(sorted_chunks)\n    \n    return result\n\ndef counting_sort(arr: List[int], max_val: int = None) -> List[int]:\n    \"\"\"Counting sort for integers in specific range\"\"\"\n    if not arr:\n        return arr\n    \n    if max_val is None:\n        max_val = max(arr)\n    \n    min_val = min(arr)\n    range_size = max_val - min_val + 1\n    \n    # Count occurrences\n    count = [0] * range_size\n    for num in arr:\n        count[num - min_val] += 1\n    \n    # Build result array\n    result = []\n    for i, freq in enumerate(count):\n        result.extend([i + min_val] * freq)\n    \n    return result\n\ndef radix_sort(arr: List[int]) -> List[int]:\n    \"\"\"Radix sort for non-negative integers\"\"\"\n    if not arr:\n        return arr\n    \n    # Find maximum number to determine number of digits\n    max_num = max(arr)\n    \n    # Sort by each digit position\n    exp = 1\n    while max_num // exp > 0:\n        arr = counting_sort_by_digit(arr, exp)\n        exp *= 10\n    \n    return arr\n\ndef counting_sort_by_digit(arr: List[int], exp: int) -> List[int]:\n    \"\"\"Counting sort by specific digit position\"\"\"\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n    \n    # Count occurrences of each digit\n    for num in arr:\n        digit = (num // exp) % 10\n        count[digit] += 1\n    \n    # Change count[i] to actual position in output\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n    \n    # Build output array\n    for i in range(n - 1, -1, -1):\n        digit = (arr[i] // exp) % 10\n        output[count[digit] - 1] = arr[i]\n        count[digit] -= 1\n    \n    return output\n\n# Demonstration\nprint(\"🚀 Advanced Sorting Algorithms Demo\")\nprint(\"=\" * 40)\n\n# Test merge sort\ntest_data = [38, 27, 43, 3, 9, 82, 10]\nprint(f\"Original: {test_data}\")\nprint(f\"Merge Sort: {merge_sort(test_data)}\")\n\n# Test k-way merge\narrays = [[1, 4, 7], [2, 5, 8], [3, 6, 9]]\nprint(f\"\\nK-way merge: {arrays} -> {k_way_merge(arrays)}\")\n\n# Test external sort simulation\nimport random\nlarge_data = [random.randint(1, 1000) for _ in range(500)]\nsorted_result = external_sort_simulation(large_data, chunk_size=50)\nprint(f\"External sort completed. First 10: {sorted_result[:10]}\")\n\n# Test counting sort\nsmall_range = [4, 2, 2, 8, 3, 3, 1]\nprint(f\"\\nCounting Sort: {small_range} -> {counting_sort(small_range)}\")\n\n# Test radix sort\nradix_data = [170, 45, 75, 90, 2, 802, 24, 66]\nprint(f\"Radix Sort: {radix_data} -> {radix_sort(radix_data)}\")",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Custom Sorting and Competitive Programming",
        "content": "Master advanced sorting techniques for competitive programming:",
        "code": "from typing import List, Tuple, Callable, Any\nfrom functools import cmp_to_key\nimport operator\n\ndef custom_sort_examples():\n    \"\"\"Demonstrate various custom sorting scenarios\"\"\"\n    \n    # Example 1: Sort students by multiple criteria\n    students = [\n        ('Alice', 85, 20),    # (name, grade, age)\n        ('Bob', 92, 19),\n        ('Charlie', 85, 21),\n        ('Diana', 92, 18),\n        ('Eve', 78, 20)\n    ]\n    \n    print(\"Original students (name, grade, age):\")\n    for student in students:\n        print(f\"  {student}\")\n    \n    # Sort by grade (descending), then by age (ascending)\n    sorted_students = sorted(students, key=lambda x: (-x[1], x[2]))\n    print(\"\\nSorted by grade (desc), then age (asc):\")\n    for student in sorted_students:\n        print(f\"  {student}\")\n    \n    # Example 2: Sort strings by custom criteria\n    words = ['python', 'java', 'c++', 'javascript', 'go', 'rust']\n    \n    # Sort by length, then alphabetically\n    sorted_words = sorted(words, key=lambda x: (len(x), x))\n    print(f\"\\nWords sorted by length, then alphabetically: {sorted_words}\")\n    \n    # Sort by number of vowels (descending)\n    def count_vowels(word):\n        return sum(1 for char in word.lower() if char in 'aeiou')\n    \n    vowel_sorted = sorted(words, key=count_vowels, reverse=True)\n    print(f\"Words sorted by vowel count (desc): {vowel_sorted}\")\n\ndef competitive_programming_problems():\n    \"\"\"Solve competitive programming problems using sorting\"\"\"\n    \n    # Problem 1: Meeting Rooms\n    def can_attend_all_meetings(intervals: List[Tuple[int, int]]) -> bool:\n        \"\"\"Check if a person can attend all meetings (no overlap)\"\"\"\n        if not intervals:\n            return True\n        \n        # Sort by start time\n        intervals.sort(key=lambda x: x[0])\n        \n        for i in range(1, len(intervals)):\n            if intervals[i][0] < intervals[i-1][1]:  # Overlap detected\n                return False\n        \n        return True\n    \n    # Problem 2: Largest Number\n    def largest_number(nums: List[int]) -> str:\n        \"\"\"Arrange numbers to form the largest possible number\"\"\"\n        # Custom comparator: x + y vs y + x\n        def compare(x, y):\n            if x + y > y + x:\n                return -1  # x should come before y\n            elif x + y < y + x:\n                return 1   # y should come before x\n            else:\n                return 0   # equal\n        \n        # Convert to strings and sort\n        str_nums = list(map(str, nums))\n        str_nums.sort(key=cmp_to_key(compare))\n        \n        # Handle edge case: all zeros\n        result = ''.join(str_nums)\n        return '0' if result[0] == '0' else result\n    \n    # Problem 3: Merge Intervals\n    def merge_intervals(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        \"\"\"Merge overlapping intervals\"\"\"\n        if not intervals:\n            return []\n        \n        # Sort by start time\n        intervals.sort(key=lambda x: x[0])\n        merged = [intervals[0]]\n        \n        for current in intervals[1:]:\n            last = merged[-1]\n            \n            if current[0] <= last[1]:  # Overlapping\n                # Merge by updating end time\n                merged[-1] = (last[0], max(last[1], current[1]))\n            else:\n                # No overlap, add as new interval\n                merged.append(current)\n        \n        return merged\n    \n    # Problem 4: Top K Frequent Elements\n    def top_k_frequent(nums: List[int], k: int) -> List[int]:\n        \"\"\"Find k most frequent elements\"\"\"\n        from collections import Counter\n        \n        # Count frequencies\n        counter = Counter(nums)\n        \n        # Sort by frequency (descending)\n        sorted_items = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n        \n        # Return top k elements\n        return [item[0] for item in sorted_items[:k]]\n    \n    # Problem 5: Custom Sort String\n    def custom_sort_string(order: str, s: str) -> str:\n        \"\"\"Sort string s according to custom order\"\"\"\n        # Create order mapping\n        order_map = {char: i for i, char in enumerate(order)}\n        \n        # Sort characters by custom order\n        sorted_chars = sorted(s, key=lambda x: order_map.get(x, len(order)))\n        \n        return ''.join(sorted_chars)\n    \n    # Test the problems\n    print(\"\\n🏆 Competitive Programming Problems\")\n    print(\"=\" * 40)\n    \n    # Test Meeting Rooms\n    meetings1 = [(0, 30), (5, 10), (15, 20)]\n    meetings2 = [(7, 10), (2, 4)]\n    print(f\"Can attend meetings {meetings1}: {can_attend_all_meetings(meetings1)}\")\n    print(f\"Can attend meetings {meetings2}: {can_attend_all_meetings(meetings2)}\")\n    \n    # Test Largest Number\n    nums1 = [10, 2]\n    nums2 = [3, 30, 34, 5, 9]\n    print(f\"Largest number from {nums1}: {largest_number(nums1)}\")\n    print(f\"Largest number from {nums2}: {largest_number(nums2)}\")\n    \n    # Test Merge Intervals\n    intervals1 = [(1, 3), (2, 6), (8, 10), (15, 18)]\n    intervals2 = [(1, 4), (4, 5)]\n    print(f\"Merge {intervals1}: {merge_intervals(intervals1)}\")\n    print(f\"Merge {intervals2}: {merge_intervals(intervals2)}\")\n    \n    # Test Top K Frequent\n    nums = [1, 1, 1, 2, 2, 3]\n    k = 2\n    print(f\"Top {k} frequent in {nums}: {top_k_frequent(nums, k)}\")\n    \n    # Test Custom Sort String\n    order = \"cba\"\n    s = \"abcd\"\n    print(f\"Custom sort '{s}' by order '{order}': {custom_sort_string(order, s)}\")\n\ndef advanced_sorting_techniques():\n    \"\"\"Advanced sorting patterns and optimizations\"\"\"\n    \n    # Stable sorting importance\n    data = [('Alice', 85), ('Bob', 90), ('Charlie', 85), ('Diana', 90)]\n    print(\"\\n🔬 Stable vs Unstable Sorting\")\n    print(f\"Original data: {data}\")\n    \n    # Sort by grade (stable)\n    stable_sorted = sorted(data, key=lambda x: x[1])\n    print(f\"Stable sort by grade: {stable_sorted}\")\n    \n    # Partial sorting with heapq\n    import heapq\n    \n    def partial_sort(arr: List[int], k: int) -> List[int]:\n        \"\"\"Get k smallest elements efficiently\"\"\"\n        return heapq.nsmallest(k, arr)\n    \n    large_array = list(range(1000, 0, -1))  # [1000, 999, 998, ..., 1]\n    k_smallest = partial_sort(large_array, 5)\n    print(f\"\\n5 smallest from large array: {k_smallest}\")\n    \n    # Sorting with custom objects\n    class Task:\n        def __init__(self, name: str, priority: int, deadline: int):\n            self.name = name\n            self.priority = priority\n            self.deadline = deadline\n        \n        def __repr__(self):\n            return f\"Task({self.name}, p={self.priority}, d={self.deadline})\"\n        \n        def __lt__(self, other):\n            # Primary: higher priority first\n            # Secondary: earlier deadline first\n            if self.priority != other.priority:\n                return self.priority > other.priority\n            return self.deadline < other.deadline\n    \n    tasks = [\n        Task(\"Email\", 1, 10),\n        Task(\"Meeting\", 3, 5),\n        Task(\"Report\", 2, 8),\n        Task(\"Urgent\", 3, 3)\n    ]\n    \n    print(\"\\n📋 Task Scheduling (Priority + Deadline):\")\n    print(\"Original tasks:\")\n    for task in tasks:\n        print(f\"  {task}\")\n    \n    sorted_tasks = sorted(tasks)\n    print(\"Sorted tasks:\")\n    for task in sorted_tasks:\n        print(f\"  {task}\")\n\n# Run all demonstrations\nprint(\"🎯 Advanced Sorting Techniques\")\nprint(\"=\" * 35)\n\ncustom_sort_examples()\ncompetitive_programming_problems()\nadvanced_sorting_techniques()",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Sort Colors (Dutch National Flag)",
        "description": "Sort an array containing only 0s, 1s, and 2s in-place.",
        "starterCode": "def sort_colors(nums):\n    # Sort array of 0s, 1s, 2s in one pass\n    # Do not use built-in sort function\n    pass\n\n# Test\ncolors = [2, 0, 2, 1, 1, 0]\nsort_colors(colors)\nprint(colors)  # Should be [0, 0, 1, 1, 2, 2]",
        "expectedOutput": "[0, 0, 1, 1, 2, 2]",
        "solution": "def sort_colors(nums):\n    left = 0  # boundary for 0s\n    right = len(nums) - 1  # boundary for 2s\n    i = 0\n    \n    while i <= right:\n        if nums[i] == 0:\n            nums[left], nums[i] = nums[i], nums[left]\n            left += 1\n            i += 1\n        elif nums[i] == 2:\n            nums[right], nums[i] = nums[i], nums[right]\n            right -= 1\n        else:  # nums[i] == 1\n            i += 1"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Kth Largest Element",
        "description": "Find the kth largest element in an unsorted array using quickselect algorithm.",
        "starterCode": "def find_kth_largest(nums, k):\n    # Find kth largest element without fully sorting\n    # Use quickselect for O(n) average time\n    pass\n\ndef partition(nums, left, right):\n    # Implement partition logic\n    pass\n\n# Test\narr = [3, 2, 1, 5, 6, 4]\nk = 2\nprint(find_kth_largest(arr, k))  # Should be 5 (2nd largest)",
        "expectedOutput": "5",
        "solution": "import random\n\ndef find_kth_largest(nums, k):\n    # Convert to kth smallest problem\n    target = len(nums) - k\n    \n    def quickselect(left, right):\n        # Randomize pivot\n        pivot_idx = random.randint(left, right)\n        nums[pivot_idx], nums[right] = nums[right], nums[pivot_idx]\n        \n        # Partition around pivot\n        store_idx = left\n        for i in range(left, right):\n            if nums[i] <= nums[right]:\n                nums[store_idx], nums[i] = nums[i], nums[store_idx]\n                store_idx += 1\n        \n        nums[store_idx], nums[right] = nums[right], nums[store_idx]\n        \n        if store_idx == target:\n            return nums[store_idx]\n        elif store_idx < target:\n            return quickselect(store_idx + 1, right)\n        else:\n            return quickselect(left, store_idx - 1)\n    \n    return quickselect(0, len(nums) - 1)"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Skyline Problem",
        "description": "Given building coordinates, find the skyline silhouette using sweep line algorithm.",
        "starterCode": "def get_skyline(buildings):\n    # buildings: [(left, right, height), ...]\n    # Return: [(x, y), ...] representing skyline points\n    # Use sweep line algorithm with events\n    pass\n\n# Test\nbuildings = [(2, 9, 10), (3, 7, 15), (5, 12, 12), (15, 20, 10), (19, 24, 8)]\nprint(get_skyline(buildings))\n# Expected: [(2, 10), (3, 15), (7, 12), (12, 0), (15, 10), (20, 8), (24, 0)]",
        "expectedOutput": "[(2, 10), (3, 15), (7, 12), (12, 0), (15, 10), (20, 8), (24, 0)]",
        "solution": "import heapq\nfrom collections import defaultdict\n\ndef get_skyline(buildings):\n    # Create events: (x, height, type) where type: 0=start, 1=end\n    events = []\n    for left, right, height in buildings:\n        events.append((left, height, 0))  # Building starts\n        events.append((right, height, 1))  # Building ends\n    \n    # Sort events by x-coordinate\n    # For same x: process starts before ends, higher buildings first\n    events.sort(key=lambda x: (x[0], x[2], -x[1] if x[2] == 0 else x[1]))\n    \n    result = []\n    max_heap = [0]  # Use negative values for max heap\n    height_count = defaultdict(int)\n    height_count[0] = 1\n    \n    for x, h, event_type in events:\n        if event_type == 0:  # Building starts\n            heapq.heappush(max_heap, -h)\n            height_count[h] += 1\n        else:  # Building ends\n            height_count[h] -= 1\n            if height_count[h] == 0:\n                del height_count[h]\n        \n        # Clean up max_heap\n        while max_heap and -max_heap[0] not in height_count:\n            heapq.heappop(max_heap)\n        \n        # Current max height\n        curr_max = -max_heap[0] if max_heap else 0\n        \n        # Add to result if height changed\n        if not result or result[-1][1] != curr_max:\n            result.append((x, curr_max))\n    \n    return result"
      },
      {
        "id": "expert-1",
        "difficulty": "Expert",
        "title": "Median of Two Sorted Arrays",
        "description": "Find median of two sorted arrays in O(log(min(m,n))) time complexity.",
        "starterCode": "def find_median_sorted_arrays(nums1, nums2):\n    # Find median of two sorted arrays efficiently\n    # Must be O(log(min(m,n))) time complexity\n    # Use binary search approach\n    pass\n\n# Test cases\nprint(find_median_sorted_arrays([1, 3], [2]))  # 2.0\nprint(find_median_sorted_arrays([1, 2], [3, 4]))  # 2.5\nprint(find_median_sorted_arrays([0, 0], [0, 0]))  # 0.0",
        "expectedOutput": "2.0\n2.5\n0.0",
        "solution": "def find_median_sorted_arrays(nums1, nums2):\n    # Ensure nums1 is the smaller array\n    if len(nums1) > len(nums2):\n        nums1, nums2 = nums2, nums1\n    \n    m, n = len(nums1), len(nums2)\n    left, right = 0, m\n    \n    while left <= right:\n        partition1 = (left + right) // 2\n        partition2 = (m + n + 1) // 2 - partition1\n        \n        # Elements on left side\n        max_left1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n        max_left2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n        \n        # Elements on right side\n        min_right1 = float('inf') if partition1 == m else nums1[partition1]\n        min_right2 = float('inf') if partition2 == n else nums2[partition2]\n        \n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            # Found correct partition\n            if (m + n) % 2 == 0:\n                return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2\n            else:\n                return max(max_left1, max_left2)\n        elif max_left1 > min_right2:\n            right = partition1 - 1\n        else:\n            left = partition1 + 1\n    \n    raise ValueError(\"Input arrays are not sorted\")"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What is the average time complexity of quicksort?",
        "type": "multiple-choice",
        "options": ["O(n)", "O(n log n)", "O(n²)", "O(log n)"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which sorting algorithm is stable and guarantees O(n log n) time?",
        "type": "multiple-choice",
        "options": ["Quicksort", "Heapsort", "Merge sort", "Selection sort"],
        "correctAnswer": 2
      },
      {
        "id": "q3",
        "question": "What is the space complexity of in-place quicksort?",
        "type": "multiple-choice",
        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "algorithms-graph",
    "title": "Graph Algorithms",
    "description": "Master graph theory and algorithms including DFS, BFS, shortest paths, and advanced graph problems.",
    "category": "Algorithms",
    "difficulty": "advanced",
    "estimatedTime": 50,
    "xpReward": 250,
    "prerequisites": ["algorithms-intro", "advanced-data-structures"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Graph Theory Fundamentals",
        "content": "Graphs are fundamental data structures representing relationships between entities. Essential concepts:\n\n• Vertices (nodes) and Edges (connections)\n• Directed vs Undirected graphs\n• Weighted vs Unweighted graphs\n• Graph representations: Adjacency Matrix, Adjacency List\n• Common graph types: Trees, DAGs, Bipartite graphs\n\nCore Algorithms:\n• Traversal: DFS, BFS\n• Shortest Path: Dijkstra, Bellman-Ford, Floyd-Warshall\n• Minimum Spanning Tree: Kruskal, Prim\n• Topological Sort\n• Strongly Connected Components\n• Network Flow algorithms\n\nApplications:\n• Social networks, routing, scheduling\n• Dependency resolution, circuit analysis\n• Game AI, recommendation systems"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Graph Representations and Basic Operations",
        "content": "Implement different graph representations and basic operations:",
        "code": "from collections import defaultdict, deque\nfrom typing import List, Dict, Set, Tuple, Optional\nimport heapq\n\nclass Graph:\n    \"\"\"Graph implementation with adjacency list\"\"\"\n    \n    def __init__(self, directed=False):\n        self.directed = directed\n        self.graph = defaultdict(list)\n        self.vertices = set()\n    \n    def add_vertex(self, vertex):\n        \"\"\"Add a vertex to the graph\"\"\"\n        self.vertices.add(vertex)\n        if vertex not in self.graph:\n            self.graph[vertex] = []\n    \n    def add_edge(self, u, v, weight=1):\n        \"\"\"Add an edge between vertices u and v\"\"\"\n        self.add_vertex(u)\n        self.add_vertex(v)\n        \n        self.graph[u].append((v, weight))\n        if not self.directed:\n            self.graph[v].append((u, weight))\n    \n    def remove_edge(self, u, v):\n        \"\"\"Remove edge between vertices u and v\"\"\"\n        self.graph[u] = [(vertex, weight) for vertex, weight in self.graph[u] if vertex != v]\n        if not self.directed:\n            self.graph[v] = [(vertex, weight) for vertex, weight in self.graph[v] if vertex != u]\n    \n    def get_neighbors(self, vertex):\n        \"\"\"Get all neighbors of a vertex\"\"\"\n        return self.graph.get(vertex, [])\n    \n    def get_vertices(self):\n        \"\"\"Get all vertices in the graph\"\"\"\n        return list(self.vertices)\n    \n    def get_edges(self):\n        \"\"\"Get all edges in the graph\"\"\"\n        edges = []\n        for u in self.graph:\n            for v, weight in self.graph[u]:\n                if self.directed or u <= v:  # Avoid duplicates in undirected graphs\n                    edges.append((u, v, weight))\n        return edges\n    \n    def has_edge(self, u, v):\n        \"\"\"Check if edge exists between u and v\"\"\"\n        return any(vertex == v for vertex, _ in self.graph.get(u, []))\n    \n    def get_edge_weight(self, u, v):\n        \"\"\"Get weight of edge between u and v\"\"\"\n        for vertex, weight in self.graph.get(u, []):\n            if vertex == v:\n                return weight\n        return None\n    \n    def print_graph(self):\n        \"\"\"Print graph structure\"\"\"\n        print(f\"Graph ({'Directed' if self.directed else 'Undirected'}):\")\n        for vertex in sorted(self.vertices):\n            neighbors = [f\"{v}({w})\" for v, w in self.graph[vertex]]\n            print(f\"  {vertex}: {', '.join(neighbors) if neighbors else '(no edges)'}\")\n\nclass WeightedGraph(Graph):\n    \"\"\"Weighted graph with additional utilities\"\"\"\n    \n    def __init__(self, directed=False):\n        super().__init__(directed)\n        self.edge_weights = {}  # (u, v) -> weight\n    \n    def add_edge(self, u, v, weight=1):\n        super().add_edge(u, v, weight)\n        self.edge_weights[(u, v)] = weight\n        if not self.directed:\n            self.edge_weights[(v, u)] = weight\n    \n    def get_weight(self, u, v):\n        \"\"\"Get weight of edge between u and v\"\"\"\n        return self.edge_weights.get((u, v), float('inf'))\n\ndef create_sample_graphs():\n    \"\"\"Create sample graphs for testing\"\"\"\n    \n    # Simple undirected graph\n    g1 = Graph(directed=False)\n    edges = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D'), ('D', 'E')]\n    for u, v in edges:\n        g1.add_edge(u, v)\n    \n    print(\"Sample Graph 1 (Undirected):\")\n    g1.print_graph()\n    \n    # Weighted directed graph\n    g2 = WeightedGraph(directed=True)\n    weighted_edges = [\n        ('S', 'A', 10), ('S', 'C', 5),\n        ('A', 'B', 1), ('A', 'C', 2),\n        ('B', 'D', 4), ('C', 'B', 9),\n        ('C', 'D', 2), ('D', 'B', 6)\n    ]\n    for u, v, w in weighted_edges:\n        g2.add_edge(u, v, w)\n    \n    print(\"\\nSample Graph 2 (Weighted, Directed):\")\n    g2.print_graph()\n    \n    return g1, g2\n\n# Matrix representation for comparison\nclass AdjacencyMatrix:\n    \"\"\"Graph representation using adjacency matrix\"\"\"\n    \n    def __init__(self, vertices):\n        self.vertices = sorted(vertices)\n        self.vertex_map = {v: i for i, v in enumerate(self.vertices)}\n        n = len(vertices)\n        self.matrix = [[0] * n for _ in range(n)]\n    \n    def add_edge(self, u, v, weight=1):\n        \"\"\"Add edge to matrix\"\"\"\n        i, j = self.vertex_map[u], self.vertex_map[v]\n        self.matrix[i][j] = weight\n    \n    def has_edge(self, u, v):\n        \"\"\"Check if edge exists\"\"\"\n        i, j = self.vertex_map[u], self.vertex_map[v]\n        return self.matrix[i][j] != 0\n    \n    def get_weight(self, u, v):\n        \"\"\"Get edge weight\"\"\"\n        i, j = self.vertex_map[u], self.vertex_map[v]\n        return self.matrix[i][j]\n    \n    def print_matrix(self):\n        \"\"\"Print adjacency matrix\"\"\"\n        print(\"Adjacency Matrix:\")\n        print(\"    \", end=\"\")\n        for v in self.vertices:\n            print(f\"{v:3}\", end=\"\")\n        print()\n        \n        for i, u in enumerate(self.vertices):\n            print(f\"{u:3} \", end=\"\")\n            for j in range(len(self.vertices)):\n                print(f\"{self.matrix[i][j]:3}\", end=\"\")\n            print()\n\ndef compare_representations():\n    \"\"\"Compare adjacency list vs matrix representations\"\"\"\n    vertices = ['A', 'B', 'C', 'D']\n    edges = [('A', 'B', 5), ('A', 'C', 3), ('B', 'D', 7), ('C', 'D', 2)]\n    \n    # Adjacency List\n    graph_list = WeightedGraph(directed=True)\n    for u, v, w in edges:\n        graph_list.add_edge(u, v, w)\n    \n    print(\"Adjacency List Representation:\")\n    graph_list.print_graph()\n    \n    # Adjacency Matrix\n    graph_matrix = AdjacencyMatrix(vertices)\n    for u, v, w in edges:\n        graph_matrix.add_edge(u, v, w)\n    \n    print(\"\\nAdjacency Matrix Representation:\")\n    graph_matrix.print_matrix()\n    \n    # Performance comparison\n    print(\"\\n📊 Performance Comparison:\")\n    print(\"Adjacency List:\")\n    print(\"  - Space: O(V + E)\")\n    print(\"  - Add edge: O(1)\")\n    print(\"  - Check edge: O(degree)\")\n    print(\"  - Get neighbors: O(degree)\")\n    \n    print(\"\\nAdjacency Matrix:\")\n    print(\"  - Space: O(V²)\")\n    print(\"  - Add edge: O(1)\")\n    print(\"  - Check edge: O(1)\")\n    print(\"  - Get neighbors: O(V)\")\n\n# Run demonstrations\nprint(\"🔗 Graph Data Structure Implementation\")\nprint(\"=\" * 45)\n\ncreate_sample_graphs()\nprint(\"\\n\" + \"=\" * 45)\ncompare_representations()",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Graph Traversal Algorithms",
        "content": "Implement and master DFS and BFS traversal algorithms:",
        "code": "from collections import deque, defaultdict\nfrom typing import List, Set, Dict, Optional, Callable\n\ndef depth_first_search(graph: Graph, start_vertex, visit_func: Optional[Callable] = None):\n    \"\"\"Depth-First Search implementation\"\"\"\n    visited = set()\n    path = []\n    \n    def dfs_recursive(vertex):\n        visited.add(vertex)\n        path.append(vertex)\n        \n        if visit_func:\n            visit_func(vertex)\n        \n        # Visit all unvisited neighbors\n        for neighbor, _ in graph.get_neighbors(vertex):\n            if neighbor not in visited:\n                dfs_recursive(neighbor)\n    \n    dfs_recursive(start_vertex)\n    return path\n\ndef depth_first_search_iterative(graph: Graph, start_vertex):\n    \"\"\"Iterative DFS using stack\"\"\"\n    visited = set()\n    path = []\n    stack = [start_vertex]\n    \n    while stack:\n        vertex = stack.pop()\n        \n        if vertex not in visited:\n            visited.add(vertex)\n            path.append(vertex)\n            \n            # Add neighbors to stack (reverse order for consistent traversal)\n            neighbors = [neighbor for neighbor, _ in graph.get_neighbors(vertex)]\n            for neighbor in reversed(neighbors):\n                if neighbor not in visited:\n                    stack.append(neighbor)\n    \n    return path\n\ndef breadth_first_search(graph: Graph, start_vertex):\n    \"\"\"Breadth-First Search implementation\"\"\"\n    visited = set()\n    path = []\n    queue = deque([start_vertex])\n    visited.add(start_vertex)\n    \n    while queue:\n        vertex = queue.popleft()\n        path.append(vertex)\n        \n        # Add all unvisited neighbors to queue\n        for neighbor, _ in graph.get_neighbors(vertex):\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n    \n    return path\n\ndef find_path_dfs(graph: Graph, start, goal):\n    \"\"\"Find path between two vertices using DFS\"\"\"\n    visited = set()\n    path = []\n    \n    def dfs_path(vertex, current_path):\n        if vertex == goal:\n            return current_path + [vertex]\n        \n        if vertex in visited:\n            return None\n        \n        visited.add(vertex)\n        \n        for neighbor, _ in graph.get_neighbors(vertex):\n            result = dfs_path(neighbor, current_path + [vertex])\n            if result:\n                return result\n        \n        return None\n    \n    return dfs_path(start, [])\n\ndef find_path_bfs(graph: Graph, start, goal):\n    \"\"\"Find shortest path between two vertices using BFS\"\"\"\n    if start == goal:\n        return [start]\n    \n    visited = set([start])\n    queue = deque([(start, [start])])\n    \n    while queue:\n        vertex, path = queue.popleft()\n        \n        for neighbor, _ in graph.get_neighbors(vertex):\n            if neighbor not in visited:\n                new_path = path + [neighbor]\n                \n                if neighbor == goal:\n                    return new_path\n                \n                visited.add(neighbor)\n                queue.append((neighbor, new_path))\n    \n    return None  # No path found\n\ndef find_all_paths_dfs(graph: Graph, start, goal, max_length=None):\n    \"\"\"Find all paths between two vertices using DFS\"\"\"\n    all_paths = []\n    \n    def dfs_all_paths(vertex, current_path, visited):\n        if vertex == goal:\n            all_paths.append(current_path + [vertex])\n            return\n        \n        if max_length and len(current_path) >= max_length:\n            return\n        \n        for neighbor, _ in graph.get_neighbors(vertex):\n            if neighbor not in visited:\n                new_visited = visited | {vertex}\n                dfs_all_paths(neighbor, current_path + [vertex], new_visited)\n    \n    dfs_all_paths(start, [], set())\n    return all_paths\n\ndef detect_cycle_dfs(graph: Graph):\n    \"\"\"Detect cycle in graph using DFS\"\"\"\n    WHITE, GRAY, BLACK = 0, 1, 2\n    colors = {vertex: WHITE for vertex in graph.get_vertices()}\n    \n    def has_cycle(vertex):\n        colors[vertex] = GRAY\n        \n        for neighbor, _ in graph.get_neighbors(vertex):\n            if colors[neighbor] == GRAY:  # Back edge found\n                return True\n            elif colors[neighbor] == WHITE and has_cycle(neighbor):\n                return True\n        \n        colors[vertex] = BLACK\n        return False\n    \n    for vertex in graph.get_vertices():\n        if colors[vertex] == WHITE:\n            if has_cycle(vertex):\n                return True\n    \n    return False\n\ndef topological_sort_dfs(graph: Graph):\n    \"\"\"Topological sort using DFS (for DAGs)\"\"\"\n    visited = set()\n    stack = []\n    \n    def dfs_topological(vertex):\n        visited.add(vertex)\n        \n        for neighbor, _ in graph.get_neighbors(vertex):\n            if neighbor not in visited:\n                dfs_topological(neighbor)\n        \n        stack.append(vertex)\n    \n    # Visit all vertices\n    for vertex in graph.get_vertices():\n        if vertex not in visited:\n            dfs_topological(vertex)\n    \n    return stack[::-1]  # Reverse to get topological order\n\ndef connected_components_dfs(graph: Graph):\n    \"\"\"Find connected components using DFS\"\"\"\n    visited = set()\n    components = []\n    \n    def dfs_component(vertex, component):\n        visited.add(vertex)\n        component.append(vertex)\n        \n        for neighbor, _ in graph.get_neighbors(vertex):\n            if neighbor not in visited:\n                dfs_component(neighbor, component)\n    \n    for vertex in graph.get_vertices():\n        if vertex not in visited:\n            component = []\n            dfs_component(vertex, component)\n            components.append(component)\n    \n    return components\n\ndef bipartite_check_bfs(graph: Graph):\n    \"\"\"Check if graph is bipartite using BFS coloring\"\"\"\n    colors = {}\n    \n    for start_vertex in graph.get_vertices():\n        if start_vertex in colors:\n            continue\n        \n        # BFS coloring starting from uncolored vertex\n        queue = deque([start_vertex])\n        colors[start_vertex] = 0\n        \n        while queue:\n            vertex = queue.popleft()\n            current_color = colors[vertex]\n            \n            for neighbor, _ in graph.get_neighbors(vertex):\n                if neighbor in colors:\n                    # Check if neighbor has different color\n                    if colors[neighbor] == current_color:\n                        return False  # Not bipartite\n                else:\n                    # Color neighbor with opposite color\n                    colors[neighbor] = 1 - current_color\n                    queue.append(neighbor)\n    \n    return True\n\ndef demonstrate_traversals():\n    \"\"\"Demonstrate various graph traversal algorithms\"\"\"\n    \n    # Create test graph\n    g = Graph(directed=False)\n    edges = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('B', 'E'), ('C', 'F'), ('E', 'F')]\n    for u, v in edges:\n        g.add_edge(u, v)\n    \n    print(\"🔍 Graph Traversal Algorithms\")\n    print(\"=\" * 35)\n    print(\"Graph structure:\")\n    g.print_graph()\n    \n    # DFS traversals\n    print(f\"\\nDFS (recursive) from A: {depth_first_search(g, 'A')}\")\n    print(f\"DFS (iterative) from A: {depth_first_search_iterative(g, 'A')}\")\n    \n    # BFS traversal\n    print(f\"BFS from A: {breadth_first_search(g, 'A')}\")\n    \n    # Path finding\n    path_dfs = find_path_dfs(g, 'A', 'F')\n    path_bfs = find_path_bfs(g, 'A', 'F')\n    print(f\"\\nPath A→F (DFS): {path_dfs}\")\n    print(f\"Path A→F (BFS): {path_bfs}\")\n    \n    # All paths\n    all_paths = find_all_paths_dfs(g, 'A', 'F', max_length=5)\n    print(f\"All paths A→F: {all_paths}\")\n    \n    # Connected components\n    # Add disconnected component\n    g.add_edge('X', 'Y')\n    components = connected_components_dfs(g)\n    print(f\"\\nConnected components: {components}\")\n    \n    # Bipartite check\n    print(f\"Is bipartite: {bipartite_check_bfs(g)}\")\n    \n    # Cycle detection (create directed graph with cycle)\n    directed_g = Graph(directed=True)\n    cycle_edges = [('A', 'B'), ('B', 'C'), ('C', 'A')]\n    for u, v in cycle_edges:\n        directed_g.add_edge(u, v)\n    \n    print(f\"\\nDirected graph has cycle: {detect_cycle_dfs(directed_g)}\")\n    \n    # Topological sort (create DAG)\n    dag = Graph(directed=True)\n    dag_edges = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D')]\n    for u, v in dag_edges:\n        dag.add_edge(u, v)\n    \n    topo_order = topological_sort_dfs(dag)\n    print(f\"Topological order: {topo_order}\")\n\n# Run demonstration\ndemonstrate_traversals()",
        "language": "python"
      },
      {
        "id": "step-4",
        "type": "code",
        "title": "Shortest Path Algorithms",
        "content": "Implement Dijkstra's, Bellman-Ford, and Floyd-Warshall algorithms:",
        "code": "import heapq\nfrom typing import Dict, List, Tuple, Optional\n\ndef dijkstra(graph: WeightedGraph, start_vertex) -> Tuple[Dict[str, float], Dict[str, Optional[str]]]:\n    \"\"\"Dijkstra's algorithm for shortest paths from single source\"\"\"\n    distances = {vertex: float('inf') for vertex in graph.get_vertices()}\n    previous = {vertex: None for vertex in graph.get_vertices()}\n    distances[start_vertex] = 0\n    \n    # Priority queue: (distance, vertex)\n    pq = [(0, start_vertex)]\n    visited = set()\n    \n    while pq:\n        current_dist, current = heapq.heappop(pq)\n        \n        if current in visited:\n            continue\n        \n        visited.add(current)\n        \n        # Check all neighbors\n        for neighbor, weight in graph.get_neighbors(current):\n            if neighbor not in visited:\n                new_dist = current_dist + weight\n                \n                if new_dist < distances[neighbor]:\n                    distances[neighbor] = new_dist\n                    previous[neighbor] = current\n                    heapq.heappush(pq, (new_dist, neighbor))\n    \n    return distances, previous\n\ndef reconstruct_path(previous: Dict[str, Optional[str]], start: str, end: str) -> List[str]:\n    \"\"\"Reconstruct shortest path from previous pointers\"\"\"\n    path = []\n    current = end\n    \n    while current is not None:\n        path.append(current)\n        current = previous[current]\n    \n    path.reverse()\n    \n    # Check if path exists\n    if path[0] != start:\n        return []  # No path found\n    \n    return path\n\ndef bellman_ford(graph: WeightedGraph, start_vertex) -> Tuple[Dict[str, float], Dict[str, Optional[str]], bool]:\n    \"\"\"Bellman-Ford algorithm (handles negative weights, detects negative cycles)\"\"\"\n    vertices = graph.get_vertices()\n    distances = {vertex: float('inf') for vertex in vertices}\n    previous = {vertex: None for vertex in vertices}\n    distances[start_vertex] = 0\n    \n    # Relax edges V-1 times\n    for _ in range(len(vertices) - 1):\n        for u in vertices:\n            if distances[u] != float('inf'):\n                for v, weight in graph.get_neighbors(u):\n                    if distances[u] + weight < distances[v]:\n                        distances[v] = distances[u] + weight\n                        previous[v] = u\n    \n    # Check for negative cycles\n    has_negative_cycle = False\n    for u in vertices:\n        if distances[u] != float('inf'):\n            for v, weight in graph.get_neighbors(u):\n                if distances[u] + weight < distances[v]:\n                    has_negative_cycle = True\n                    break\n        if has_negative_cycle:\n            break\n    \n    return distances, previous, has_negative_cycle\n\ndef floyd_warshall(graph: WeightedGraph) -> Tuple[Dict[Tuple[str, str], float], Dict[Tuple[str, str], Optional[str]]]:\n    \"\"\"Floyd-Warshall algorithm for all-pairs shortest paths\"\"\"\n    vertices = graph.get_vertices()\n    n = len(vertices)\n    vertex_to_index = {v: i for i, v in enumerate(vertices)}\n    \n    # Initialize distance matrix\n    dist = [[float('inf')] * n for _ in range(n)]\n    next_vertex = [[None] * n for _ in range(n)]\n    \n    # Distance from vertex to itself is 0\n    for i in range(n):\n        dist[i][i] = 0\n    \n    # Initialize with direct edges\n    for u in vertices:\n        for v, weight in graph.get_neighbors(u):\n            i, j = vertex_to_index[u], vertex_to_index[v]\n            dist[i][j] = weight\n            next_vertex[i][j] = v\n    \n    # Floyd-Warshall main algorithm\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                if dist[i][k] + dist[k][j] < dist[i][j]:\n                    dist[i][j] = dist[i][k] + dist[k][j]\n                    next_vertex[i][j] = next_vertex[i][k]\n    \n    # Convert back to dictionary format\n    distances = {}\n    previous = {}\n    \n    for i, u in enumerate(vertices):\n        for j, v in enumerate(vertices):\n            distances[(u, v)] = dist[i][j]\n            previous[(u, v)] = next_vertex[i][j]\n    \n    return distances, previous\n\ndef reconstruct_floyd_warshall_path(next_vertex: Dict[Tuple[str, str], Optional[str]], start: str, end: str) -> List[str]:\n    \"\"\"Reconstruct path from Floyd-Warshall next matrix\"\"\"\n    if next_vertex[(start, end)] is None:\n        return []\n    \n    path = [start]\n    current = start\n    \n    while current != end:\n        current = next_vertex[(current, end)]\n        path.append(current)\n    \n    return path\n\ndef a_star_search(graph: WeightedGraph, start: str, goal: str, heuristic: Dict[str, float]) -> Tuple[List[str], float]:\n    \"\"\"A* search algorithm with heuristic\"\"\"\n    open_set = [(0, start)]  # (f_score, vertex)\n    came_from = {}\n    g_score = {vertex: float('inf') for vertex in graph.get_vertices()}\n    g_score[start] = 0\n    f_score = {vertex: float('inf') for vertex in graph.get_vertices()}\n    f_score[start] = heuristic.get(start, 0)\n    \n    open_set_hash = {start}\n    \n    while open_set:\n        current = heapq.heappop(open_set)[1]\n        open_set_hash.remove(current)\n        \n        if current == goal:\n            # Reconstruct path\n            path = []\n            while current in came_from:\n                path.append(current)\n                current = came_from[current]\n            path.append(start)\n            return path[::-1], g_score[goal]\n        \n        for neighbor, weight in graph.get_neighbors(current):\n            tentative_g_score = g_score[current] + weight\n            \n            if tentative_g_score < g_score[neighbor]:\n                came_from[neighbor] = current\n                g_score[neighbor] = tentative_g_score\n                f_score[neighbor] = g_score[neighbor] + heuristic.get(neighbor, 0)\n                \n                if neighbor not in open_set_hash:\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\n                    open_set_hash.add(neighbor)\n    \n    return [], float('inf')  # No path found\n\ndef demonstrate_shortest_paths():\n    \"\"\"Demonstrate shortest path algorithms\"\"\"\n    \n    print(\"🛣️  Shortest Path Algorithms\")\n    print(\"=\" * 35)\n    \n    # Create weighted directed graph\n    g = WeightedGraph(directed=True)\n    edges = [\n        ('A', 'B', 4), ('A', 'C', 2),\n        ('B', 'C', 1), ('B', 'D', 5),\n        ('C', 'D', 8), ('C', 'E', 10),\n        ('D', 'E', 2), ('D', 'F', 6),\n        ('E', 'F', 3)\n    ]\n    \n    for u, v, w in edges:\n        g.add_edge(u, v, w)\n    \n    print(\"Graph:\")\n    g.print_graph()\n    \n    # Dijkstra's algorithm\n    print(\"\\n🔍 Dijkstra's Algorithm (from A):\")\n    distances, previous = dijkstra(g, 'A')\n    \n    for vertex in sorted(distances.keys()):\n        if distances[vertex] != float('inf'):\n            path = reconstruct_path(previous, 'A', vertex)\n            print(f\"  A → {vertex}: distance = {distances[vertex]}, path = {' → '.join(path)}\")\n    \n    # Bellman-Ford algorithm\n    print(\"\\n🔍 Bellman-Ford Algorithm (from A):\")\n    bf_distances, bf_previous, has_negative_cycle = bellman_ford(g, 'A')\n    \n    if has_negative_cycle:\n        print(\"  Negative cycle detected!\")\n    else:\n        for vertex in sorted(bf_distances.keys()):\n            if bf_distances[vertex] != float('inf'):\n                path = reconstruct_path(bf_previous, 'A', vertex)\n                print(f\"  A → {vertex}: distance = {bf_distances[vertex]}, path = {' → '.join(path)}\")\n    \n    # Floyd-Warshall algorithm\n    print(\"\\n🔍 Floyd-Warshall Algorithm (all pairs):\")\n    fw_distances, fw_next = floyd_warshall(g)\n    \n    # Print distance matrix\n    vertices = sorted(g.get_vertices())\n    print(\"Distance matrix:\")\n    print(\"     \", end=\"\")\n    for v in vertices:\n        print(f\"{v:6}\", end=\"\")\n    print()\n    \n    for u in vertices:\n        print(f\"{u:4} \", end=\"\")\n        for v in vertices:\n            dist = fw_distances[(u, v)]\n            if dist == float('inf'):\n                print(\"   ∞ \", end=\"\")\n            else:\n                print(f\"{dist:6.1f}\", end=\"\")\n        print()\n    \n    # A* search example\n    print(\"\\n🔍 A* Search (A → F):\")\n    # Simple heuristic: distance to F (estimated)\n    heuristic = {'A': 10, 'B': 8, 'C': 9, 'D': 4, 'E': 2, 'F': 0}\n    \n    a_star_path, a_star_cost = a_star_search(g, 'A', 'F', heuristic)\n    if a_star_path:\n        print(f\"  Path: {' → '.join(a_star_path)}\")\n        print(f\"  Cost: {a_star_cost}\")\n    else:\n        print(\"  No path found\")\n    \n    # Test with negative weights\n    print(\"\\n🔍 Testing Negative Weights:\")\n    g_neg = WeightedGraph(directed=True)\n    neg_edges = [('X', 'Y', 1), ('Y', 'Z', -3), ('Z', 'X', 1)]\n    for u, v, w in neg_edges:\n        g_neg.add_edge(u, v, w)\n    \n    print(\"Graph with negative weights:\")\n    g_neg.print_graph()\n    \n    bf_dist_neg, bf_prev_neg, neg_cycle = bellman_ford(g_neg, 'X')\n    print(f\"Has negative cycle: {neg_cycle}\")\n    \n    if not neg_cycle:\n        for vertex in sorted(bf_dist_neg.keys()):\n            if bf_dist_neg[vertex] != float('inf'):\n                print(f\"  X → {vertex}: {bf_dist_neg[vertex]}\")\n\n# Run demonstration\ndemonstrate_shortest_paths()",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Clone Graph",
        "description": "Given a reference to a node in a connected undirected graph, return a deep copy of the graph.",
        "starterCode": "class Node:\n    def __init__(self, val=0, neighbors=None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\ndef clone_graph(node):\n    # Return deep copy of the graph\n    # Use DFS or BFS to traverse and clone\n    pass\n\n# Test\nnode1 = Node(1)\nnode2 = Node(2)\nnode1.neighbors = [node2]\nnode2.neighbors = [node1]\n\ncloned = clone_graph(node1)\nprint(f\"Original: {node1.val}, Cloned: {cloned.val}\")\nprint(f\"Different objects: {node1 is not cloned}\")",
        "expectedOutput": "Original: 1, Cloned: 1\nDifferent objects: True",
        "solution": "def clone_graph(node):\n    if not node:\n        return None\n    \n    visited = {}\n    \n    def dfs(node):\n        if node in visited:\n            return visited[node]\n        \n        # Create clone\n        clone = Node(node.val)\n        visited[node] = clone\n        \n        # Clone neighbors\n        for neighbor in node.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Course Schedule",
        "description": "There are numCourses courses labeled from 0 to numCourses-1. Given prerequisites, determine if you can finish all courses.",
        "starterCode": "def can_finish(num_courses, prerequisites):\n    # Check if course schedule is possible (no cycles)\n    # Use topological sort or cycle detection\n    pass\n\n# Test\nprint(can_finish(2, [[1,0]]))  # True\nprint(can_finish(2, [[1,0],[0,1]]))  # False (cycle)",
        "expectedOutput": "True\nFalse",
        "solution": "def can_finish(num_courses, prerequisites):\n    from collections import defaultdict, deque\n    \n    # Build graph and calculate in-degrees\n    graph = defaultdict(list)\n    in_degree = [0] * num_courses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    # Start with courses having no prerequisites\n    queue = deque([i for i in range(num_courses) if in_degree[i] == 0])\n    completed = 0\n    \n    while queue:\n        course = queue.popleft()\n        completed += 1\n        \n        # Remove this course and update in-degrees\n        for next_course in graph[course]:\n            in_degree[next_course] -= 1\n            if in_degree[next_course] == 0:\n                queue.append(next_course)\n    \n    return completed == num_courses"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Network Delay Time",
        "description": "Find the minimum time for all nodes to receive a signal sent from node K.",
        "starterCode": "def network_delay_time(times, n, k):\n    # times[i] = (u, v, w) means signal travels from u to v in w time\n    # Return minimum time for all n nodes to receive signal from k\n    # Return -1 if impossible\n    pass\n\n# Test\ntimes = [[2,1,1],[2,3,1],[3,4,1]]\nn = 4\nk = 2\nprint(network_delay_time(times, n, k))  # Should return 2",
        "expectedOutput": "2",
        "solution": "import heapq\n\ndef network_delay_time(times, n, k):\n    # Build graph\n    graph = {}\n    for i in range(1, n + 1):\n        graph[i] = []\n    \n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    # Dijkstra's algorithm\n    distances = {i: float('inf') for i in range(1, n + 1)}\n    distances[k] = 0\n    pq = [(0, k)]\n    \n    while pq:\n        current_dist, node = heapq.heappop(pq)\n        \n        if current_dist > distances[node]:\n            continue\n        \n        for neighbor, weight in graph[node]:\n            new_dist = current_dist + weight\n            if new_dist < distances[neighbor]:\n                distances[neighbor] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    \n    max_time = max(distances.values())\n    return max_time if max_time != float('inf') else -1"
      },
      {
        "id": "expert-1",
        "difficulty": "Expert",
        "title": "Alien Dictionary",
        "description": "Given a sorted dictionary of alien language, find the order of characters.",
        "starterCode": "def alien_order(words):\n    # Given sorted dictionary, determine character order\n    # Return lexicographically smallest valid ordering\n    # Return empty string if no valid ordering exists\n    pass\n\n# Test\nwords1 = [\"wrt\", \"wrf\", \"er\", \"ett\", \"rftt\"]\nprint(alien_order(words1))  # One possible: \"wertf\"",
        "expectedOutput": "wertf",
        "solution": "def alien_order(words):\n    from collections import defaultdict, deque\n    \n    # Build graph and in-degree\n    graph = defaultdict(set)\n    in_degree = defaultdict(int)\n    \n    # Initialize all characters\n    for word in words:\n        for char in word:\n            in_degree[char] = 0\n    \n    # Build edges by comparing adjacent words\n    for i in range(len(words) - 1):\n        word1, word2 = words[i], words[i + 1]\n        min_len = min(len(word1), len(word2))\n        \n        # Check for invalid case: word1 is prefix of word2 but longer\n        if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:\n            return \"\"\n        \n        # Find first different character\n        for j in range(min_len):\n            if word1[j] != word2[j]:\n                if word2[j] not in graph[word1[j]]:\n                    graph[word1[j]].add(word2[j])\n                    in_degree[word2[j]] += 1\n                break\n    \n    # Topological sort\n    queue = deque([char for char in in_degree if in_degree[char] == 0])\n    result = []\n    \n    while queue:\n        char = queue.popleft()\n        result.append(char)\n        \n        for next_char in graph[char]:\n            in_degree[next_char] -= 1\n            if in_degree[next_char] == 0:\n                queue.append(next_char)\n    \n    # Check if all characters are included (no cycle)\n    if len(result) != len(in_degree):\n        return \"\"\n    \n    return ''.join(result)"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What is the time complexity of Dijkstra's algorithm with binary heap?",
        "type": "multiple-choice",
        "options": ["O(V²)", "O(E log V)", "O(V log E)", "O(E + V log V)"],
        "correctAnswer": 3
      },
      {
        "id": "q2",
        "question": "Which algorithm can handle negative edge weights?",
        "type": "multiple-choice",
        "options": ["Dijkstra's", "Bellman-Ford", "A*", "Greedy BFS"],
        "correctAnswer": 1
      },
      {
        "id": "q3",
        "question": "What is the space complexity of adjacency list representation?",
        "type": "multiple-choice",
        "options": ["O(V)", "O(E)", "O(V + E)", "O(V²)"],
        "correctAnswer": 2
      }
    ]
  },
  {
    "id": "oop-design-patterns",
    "title": "Design Patterns in Python",
    "description": "Master essential design patterns: Singleton, Factory, Observer, Strategy, and more advanced patterns.",
    "category": "Object-Oriented Programming",
    "difficulty": "advanced",
    "estimatedTime": 45,
    "xpReward": 200,
    "prerequisites": ["python-classes"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Design Patterns Overview",
        "content": "Design patterns are reusable solutions to common problems in software design. They represent best practices and proven solutions.\n\n**Creational Patterns:**\n• Singleton: Ensure only one instance exists\n• Factory: Create objects without specifying exact classes\n• Builder: Construct complex objects step by step\n• Prototype: Create objects by cloning existing instances\n\n**Structural Patterns:**\n• Adapter: Allow incompatible interfaces to work together\n• Decorator: Add behavior to objects dynamically\n• Facade: Provide simplified interface to complex systems\n• Composite: Treat individual and composite objects uniformly\n\n**Behavioral Patterns:**\n• Observer: Define one-to-many dependency between objects\n• Strategy: Define family of algorithms and make them interchangeable\n• Command: Encapsulate requests as objects\n• State: Allow object to alter behavior when internal state changes"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Creational Patterns Implementation",
        "content": "Implement essential creational design patterns:",
        "code": "import threading\nfrom abc import ABC, abstractmethod\nfrom typing import Dict, Any, Optional, List\nfrom copy import deepcopy\n\n# 1. SINGLETON PATTERN\nclass Singleton:\n    \"\"\"Thread-safe Singleton implementation\"\"\"\n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def __init__(self):\n        if not hasattr(self, 'initialized'):\n            self.initialized = True\n            self.data = {}\n    \n    def set_data(self, key: str, value: Any):\n        self.data[key] = value\n    \n    def get_data(self, key: str) -> Any:\n        return self.data.get(key)\n\nclass DatabaseConnection(Singleton):\n    \"\"\"Singleton database connection example\"\"\"\n    def __init__(self):\n        super().__init__()\n        if not hasattr(self, 'connection_string'):\n            self.connection_string = \"postgresql://localhost:5432/mydb\"\n            self.is_connected = False\n    \n    def connect(self):\n        if not self.is_connected:\n            print(f\"Connecting to database: {self.connection_string}\")\n            self.is_connected = True\n        return self\n    \n    def query(self, sql: str):\n        if self.is_connected:\n            return f\"Executing: {sql}\"\n        return \"Not connected to database\"\n\n# 2. FACTORY PATTERN\nclass Animal(ABC):\n    \"\"\"Abstract base class for animals\"\"\"\n    @abstractmethod\n    def make_sound(self) -> str:\n        pass\n    \n    @abstractmethod\n    def get_type(self) -> str:\n        pass\n\nclass Dog(Animal):\n    def make_sound(self) -> str:\n        return \"Woof!\"\n    \n    def get_type(self) -> str:\n        return \"Canine\"\n\nclass Cat(Animal):\n    def make_sound(self) -> str:\n        return \"Meow!\"\n    \n    def get_type(self) -> str:\n        return \"Feline\"\n\nclass Bird(Animal):\n    def make_sound(self) -> str:\n        return \"Tweet!\"\n    \n    def get_type(self) -> str:\n        return \"Avian\"\n\nclass AnimalFactory:\n    \"\"\"Factory for creating animals\"\"\"\n    \n    @staticmethod\n    def create_animal(animal_type: str) -> Animal:\n        animals = {\n            'dog': Dog,\n            'cat': Cat,\n            'bird': Bird\n        }\n        \n        animal_class = animals.get(animal_type.lower())\n        if animal_class:\n            return animal_class()\n        else:\n            raise ValueError(f\"Unknown animal type: {animal_type}\")\n    \n    @staticmethod\n    def get_available_animals() -> List[str]:\n        return ['dog', 'cat', 'bird']\n\n# 3. BUILDER PATTERN\nclass Computer:\n    \"\"\"Product class for Builder pattern\"\"\"\n    def __init__(self):\n        self.cpu = None\n        self.memory = None\n        self.storage = None\n        self.graphics = None\n        self.operating_system = None\n    \n    def __str__(self):\n        return (f\"Computer: CPU={self.cpu}, Memory={self.memory}, \"\n                f\"Storage={self.storage}, Graphics={self.graphics}, OS={self.operating_system}\")\n\nclass ComputerBuilder:\n    \"\"\"Builder for constructing computers\"\"\"\n    def __init__(self):\n        self.computer = Computer()\n    \n    def set_cpu(self, cpu: str):\n        self.computer.cpu = cpu\n        return self\n    \n    def set_memory(self, memory: str):\n        self.computer.memory = memory\n        return self\n    \n    def set_storage(self, storage: str):\n        self.computer.storage = storage\n        return self\n    \n    def set_graphics(self, graphics: str):\n        self.computer.graphics = graphics\n        return self\n    \n    def set_os(self, os: str):\n        self.computer.operating_system = os\n        return self\n    \n    def build(self) -> Computer:\n        return self.computer\n\nclass ComputerDirector:\n    \"\"\"Director that knows how to build specific computer configurations\"\"\"\n    \n    @staticmethod\n    def build_gaming_pc() -> Computer:\n        return (ComputerBuilder()\n                .set_cpu(\"Intel i9-12900K\")\n                .set_memory(\"32GB DDR4\")\n                .set_storage(\"1TB NVMe SSD\")\n                .set_graphics(\"RTX 4080\")\n                .set_os(\"Windows 11\")\n                .build())\n    \n    @staticmethod\n    def build_office_pc() -> Computer:\n        return (ComputerBuilder()\n                .set_cpu(\"Intel i5-12400\")\n                .set_memory(\"16GB DDR4\")\n                .set_storage(\"512GB SSD\")\n                .set_graphics(\"Integrated\")\n                .set_os(\"Windows 11\")\n                .build())\n    \n    @staticmethod\n    def build_dev_laptop() -> Computer:\n        return (ComputerBuilder()\n                .set_cpu(\"Apple M2 Pro\")\n                .set_memory(\"16GB Unified\")\n                .set_storage(\"512GB SSD\")\n                .set_graphics(\"Integrated\")\n                .set_os(\"macOS\")\n                .build())\n\n# 4. PROTOTYPE PATTERN\nclass Prototype(ABC):\n    \"\"\"Abstract prototype interface\"\"\"\n    @abstractmethod\n    def clone(self):\n        pass\n\nclass Document(Prototype):\n    \"\"\"Document that can be cloned\"\"\"\n    def __init__(self, title: str, content: str, metadata: Dict[str, Any] = None):\n        self.title = title\n        self.content = content\n        self.metadata = metadata or {}\n        self.created_at = \"2024-01-15T10:00:00\"\n    \n    def clone(self):\n        \"\"\"Create a deep copy of the document\"\"\"\n        cloned = Document(self.title, self.content, deepcopy(self.metadata))\n        cloned.created_at = self.created_at\n        return cloned\n    \n    def set_title(self, title: str):\n        self.title = title\n    \n    def set_content(self, content: str):\n        self.content = content\n    \n    def add_metadata(self, key: str, value: Any):\n        self.metadata[key] = value\n    \n    def __str__(self):\n        return f\"Document(title='{self.title}', content_length={len(self.content)}, metadata={self.metadata})\"\n\nclass DocumentRegistry:\n    \"\"\"Registry for managing document prototypes\"\"\"\n    def __init__(self):\n        self._prototypes: Dict[str, Document] = {}\n    \n    def register_prototype(self, name: str, prototype: Document):\n        self._prototypes[name] = prototype\n    \n    def create_document(self, prototype_name: str) -> Optional[Document]:\n        prototype = self._prototypes.get(prototype_name)\n        return prototype.clone() if prototype else None\n    \n    def list_prototypes(self) -> List[str]:\n        return list(self._prototypes.keys())\n\ndef demonstrate_creational_patterns():\n    \"\"\"Demonstrate all creational patterns\"\"\"\n    print(\"🏗️ Creational Design Patterns\")\n    print(\"=\" * 35)\n    \n    # 1. Singleton Pattern\n    print(\"\\n1. SINGLETON PATTERN:\")\n    db1 = DatabaseConnection()\n    db2 = DatabaseConnection()\n    \n    print(f\"Same instance: {db1 is db2}\")\n    db1.connect()\n    result = db1.query(\"SELECT * FROM users\")\n    print(f\"Query result: {result}\")\n    \n    # 2. Factory Pattern\n    print(\"\\n2. FACTORY PATTERN:\")\n    print(f\"Available animals: {AnimalFactory.get_available_animals()}\")\n    \n    for animal_type in ['dog', 'cat', 'bird']:\n        animal = AnimalFactory.create_animal(animal_type)\n        print(f\"{animal_type.title()}: {animal.make_sound()} (Type: {animal.get_type()})\")\n    \n    # 3. Builder Pattern\n    print(\"\\n3. BUILDER PATTERN:\")\n    gaming_pc = ComputerDirector.build_gaming_pc()\n    office_pc = ComputerDirector.build_office_pc()\n    dev_laptop = ComputerDirector.build_dev_laptop()\n    \n    print(f\"Gaming PC: {gaming_pc}\")\n    print(f\"Office PC: {office_pc}\")\n    print(f\"Dev Laptop: {dev_laptop}\")\n    \n    # Custom build\n    custom_pc = (ComputerBuilder()\n                 .set_cpu(\"AMD Ryzen 9\")\n                 .set_memory(\"64GB DDR5\")\n                 .set_storage(\"2TB NVMe\")\n                 .set_graphics(\"RTX 4090\")\n                 .set_os(\"Linux\")\n                 .build())\n    print(f\"Custom PC: {custom_pc}\")\n    \n    # 4. Prototype Pattern\n    print(\"\\n4. PROTOTYPE PATTERN:\")\n    registry = DocumentRegistry()\n    \n    # Create and register prototypes\n    report_template = Document(\"Monthly Report\", \"## Summary\\n\\n## Details\\n\\n## Conclusion\")\n    report_template.add_metadata(\"type\", \"report\")\n    report_template.add_metadata(\"template_version\", \"1.0\")\n    \n    letter_template = Document(\"Business Letter\", \"Dear [Name],\\n\\n[Content]\\n\\nSincerely,\\n[Sender]\")\n    letter_template.add_metadata(\"type\", \"letter\")\n    \n    registry.register_prototype(\"report\", report_template)\n    registry.register_prototype(\"letter\", letter_template)\n    \n    print(f\"Available prototypes: {registry.list_prototypes()}\")\n    \n    # Create documents from prototypes\n    january_report = registry.create_document(\"report\")\n    january_report.set_title(\"January 2024 Report\")\n    january_report.add_metadata(\"month\", \"January\")\n    \n    welcome_letter = registry.create_document(\"letter\")\n    welcome_letter.set_title(\"Welcome Letter\")\n    welcome_letter.set_content(\"Dear New Employee,\\n\\nWelcome to our company!\\n\\nSincerely,\\nHR Team\")\n    \n    print(f\"January Report: {january_report}\")\n    print(f\"Welcome Letter: {welcome_letter}\")\n    print(f\"Original template unchanged: {report_template}\")\n\n# Run demonstration\ndemonstrate_creational_patterns()",
        "language": "python"
      },
      {
        "id": "step-3",
        "type": "code",
        "title": "Structural Patterns Implementation",
        "content": "Implement key structural design patterns:",
        "code": "from abc import ABC, abstractmethod\nfrom typing import List, Any, Dict, Callable\n\n# 1. ADAPTER PATTERN\nclass LegacyPrinter:\n    \"\"\"Legacy printer with old interface\"\"\"\n    def old_print(self, text: str):\n        return f\"[LEGACY] Printing: {text}\"\n\nclass ModernPrinter:\n    \"\"\"Modern printer with new interface\"\"\"\n    def print_document(self, document: str, options: Dict[str, Any] = None):\n        options = options or {}\n        copies = options.get('copies', 1)\n        color = options.get('color', False)\n        mode = 'COLOR' if color else 'B&W'\n        return f\"[MODERN] {mode} Printing {copies} copies: {document}\"\n\nclass PrinterAdapter:\n    \"\"\"Adapter to make legacy printer work with modern interface\"\"\"\n    def __init__(self, legacy_printer: LegacyPrinter):\n        self.legacy_printer = legacy_printer\n    \n    def print_document(self, document: str, options: Dict[str, Any] = None):\n        # Adapt modern interface to legacy interface\n        options = options or {}\n        copies = options.get('copies', 1)\n        \n        results = []\n        for i in range(copies):\n            result = self.legacy_printer.old_print(document)\n            results.append(f\"Copy {i+1}: {result}\")\n        \n        return \"\\n\".join(results)\n\n# 2. DECORATOR PATTERN\nclass Component(ABC):\n    \"\"\"Abstract component interface\"\"\"\n    @abstractmethod\n    def operation(self) -> str:\n        pass\n\nclass ConcreteComponent(Component):\n    \"\"\"Concrete component with basic functionality\"\"\"\n    def operation(self) -> str:\n        return \"Basic operation\"\n\nclass Decorator(Component):\n    \"\"\"Base decorator class\"\"\"\n    def __init__(self, component: Component):\n        self._component = component\n    \n    def operation(self) -> str:\n        return self._component.operation()\n\nclass LoggingDecorator(Decorator):\n    \"\"\"Decorator that adds logging functionality\"\"\"\n    def operation(self) -> str:\n        result = self._component.operation()\n        return f\"[LOG] {result} [/LOG]\"\n\nclass EncryptionDecorator(Decorator):\n    \"\"\"Decorator that adds encryption functionality\"\"\"\n    def operation(self) -> str:\n        result = self._component.operation()\n        # Simulate encryption (just reverse the string)\n        encrypted = result[::-1]\n        return f\"[ENCRYPTED] {encrypted} [/ENCRYPTED]\"\n\nclass CompressionDecorator(Decorator):\n    \"\"\"Decorator that adds compression functionality\"\"\"\n    def operation(self) -> str:\n        result = self._component.operation()\n        # Simulate compression (just abbreviate)\n        compressed = result.replace(\"operation\", \"op\").replace(\"Basic\", \"B\")\n        return f\"[COMPRESSED] {compressed} [/COMPRESSED]\"\n\n# 3. FACADE PATTERN\nclass CPU:\n    \"\"\"Complex subsystem component\"\"\"\n    def freeze(self):\n        return \"CPU: Freezing processor\"\n    \n    def jump(self, position: int):\n        return f\"CPU: Jumping to position {position}\"\n    \n    def execute(self):\n        return \"CPU: Executing instructions\"\n\nclass Memory:\n    \"\"\"Complex subsystem component\"\"\"\n    def load(self, position: int, data: str):\n        return f\"Memory: Loading '{data}' at position {position}\"\n\nclass HardDrive:\n    \"\"\"Complex subsystem component\"\"\"\n    def read(self, lba: int, size: int):\n        return f\"HDD: Reading {size} bytes from LBA {lba}\"\n\nclass ComputerFacade:\n    \"\"\"Facade that provides simple interface to complex subsystem\"\"\"\n    def __init__(self):\n        self.cpu = CPU()\n        self.memory = Memory()\n        self.hard_drive = HardDrive()\n    \n    def start_computer(self):\n        \"\"\"Simple interface for complex boot process\"\"\"\n        operations = [\n            self.cpu.freeze(),\n            self.memory.load(0, \"boot_sector\"),\n            self.hard_drive.read(0, 1024),\n            self.cpu.jump(0),\n            self.cpu.execute()\n        ]\n        return \"Computer started successfully:\\n\" + \"\\n\".join(f\"  {op}\" for op in operations)\n\n# 4. COMPOSITE PATTERN\nclass FileSystemComponent(ABC):\n    \"\"\"Abstract base for file system components\"\"\"\n    def __init__(self, name: str):\n        self.name = name\n    \n    @abstractmethod\n    def get_size(self) -> int:\n        pass\n    \n    @abstractmethod\n    def display(self, indent: int = 0) -> str:\n        pass\n\nclass File(FileSystemComponent):\n    \"\"\"Leaf component representing a file\"\"\"\n    def __init__(self, name: str, size: int):\n        super().__init__(name)\n        self.size = size\n    \n    def get_size(self) -> int:\n        return self.size\n    \n    def display(self, indent: int = 0) -> str:\n        return \"  \" * indent + f\"📄 {self.name} ({self.size} bytes)\"\n\nclass Directory(FileSystemComponent):\n    \"\"\"Composite component representing a directory\"\"\"\n    def __init__(self, name: str):\n        super().__init__(name)\n        self.children: List[FileSystemComponent] = []\n    \n    def add(self, component: FileSystemComponent):\n        self.children.append(component)\n    \n    def remove(self, component: FileSystemComponent):\n        self.children.remove(component)\n    \n    def get_size(self) -> int:\n        return sum(child.get_size() for child in self.children)\n    \n    def display(self, indent: int = 0) -> str:\n        result = \"  \" * indent + f\"📁 {self.name}/ ({self.get_size()} bytes total)\\n\"\n        for child in self.children:\n            result += child.display(indent + 1) + \"\\n\"\n        return result.rstrip()\n\n# 5. PROXY PATTERN\nclass Image(ABC):\n    \"\"\"Abstract image interface\"\"\"\n    @abstractmethod\n    def display(self) -> str:\n        pass\n\nclass RealImage(Image):\n    \"\"\"Real image that loads from disk\"\"\"\n    def __init__(self, filename: str):\n        self.filename = filename\n        self._load_from_disk()\n    \n    def _load_from_disk(self):\n        print(f\"Loading image from disk: {self.filename}\")\n    \n    def display(self) -> str:\n        return f\"Displaying image: {self.filename}\"\n\nclass ImageProxy(Image):\n    \"\"\"Proxy that delays loading until needed\"\"\"\n    def __init__(self, filename: str):\n        self.filename = filename\n        self._real_image = None\n    \n    def display(self) -> str:\n        if self._real_image is None:\n            self._real_image = RealImage(self.filename)\n        return self._real_image.display()\n\ndef demonstrate_structural_patterns():\n    \"\"\"Demonstrate all structural patterns\"\"\"\n    print(\"🏗️ Structural Design Patterns\")\n    print(\"=\" * 35)\n    \n    # 1. Adapter Pattern\n    print(\"\\n1. ADAPTER PATTERN:\")\n    legacy_printer = LegacyPrinter()\n    modern_printer = ModernPrinter()\n    adapter = PrinterAdapter(legacy_printer)\n    \n    # Use modern interface with both printers\n    doc = \"Important Document\"\n    options = {'copies': 2, 'color': True}\n    \n    print(\"Modern printer:\")\n    print(modern_printer.print_document(doc, options))\n    \n    print(\"\\nLegacy printer via adapter:\")\n    print(adapter.print_document(doc, options))\n    \n    # 2. Decorator Pattern\n    print(\"\\n2. DECORATOR PATTERN:\")\n    component = ConcreteComponent()\n    \n    print(f\"Basic: {component.operation()}\")\n    \n    logged = LoggingDecorator(component)\n    print(f\"With logging: {logged.operation()}\")\n    \n    encrypted = EncryptionDecorator(logged)\n    print(f\"With encryption: {encrypted.operation()}\")\n    \n    compressed = CompressionDecorator(encrypted)\n    print(f\"With compression: {compressed.operation()}\")\n    \n    # 3. Facade Pattern\n    print(\"\\n3. FACADE PATTERN:\")\n    computer = ComputerFacade()\n    print(computer.start_computer())\n    \n    # 4. Composite Pattern\n    print(\"\\n4. COMPOSITE PATTERN:\")\n    root = Directory(\"root\")\n    \n    # Create files\n    file1 = File(\"document.txt\", 1024)\n    file2 = File(\"image.jpg\", 2048)\n    file3 = File(\"config.ini\", 512)\n    \n    # Create subdirectories\n    docs_dir = Directory(\"documents\")\n    images_dir = Directory(\"images\")\n    \n    # Build file system structure\n    docs_dir.add(file1)\n    docs_dir.add(file3)\n    images_dir.add(file2)\n    \n    root.add(docs_dir)\n    root.add(images_dir)\n    root.add(File(\"readme.txt\", 256))\n    \n    print(\"File system structure:\")\n    print(root.display())\n    \n    # 5. Proxy Pattern\n    print(\"\\n5. PROXY PATTERN:\")\n    images = [\n        ImageProxy(\"photo1.jpg\"),\n        ImageProxy(\"photo2.jpg\"),\n        ImageProxy(\"photo3.jpg\")\n    ]\n    \n    print(\"Images created (not loaded yet)\")\n    \n    # Images are loaded only when displayed\n    print(\"\\nDisplaying first image:\")\n    print(images[0].display())\n    \n    print(\"\\nDisplaying second image:\")\n    print(images[1].display())\n    \n    print(\"\\nDisplaying first image again (already loaded):\")\n    print(images[0].display())\n\n# Run demonstration\ndemonstrate_structural_patterns()",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Implement Singleton Logger",
        "description": "Create a thread-safe Singleton logger class that writes to file and console.",
        "starterCode": "import threading\n\nclass Logger:\n    # Implement Singleton pattern\n    # Add methods: log_info, log_error, log_debug\n    pass\n\n# Test\nlogger1 = Logger()\nlogger2 = Logger()\nprint(f\"Same instance: {logger1 is logger2}\")\nlogger1.log_info(\"Test message\")",
        "expectedOutput": "Same instance: True\n[INFO] Test message",
        "solution": "import threading\nfrom datetime import datetime\n\nclass Logger:\n    _instance = None\n    _lock = threading.Lock()\n    \n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super().__new__(cls)\n        return cls._instance\n    \n    def __init__(self):\n        if not hasattr(self, 'initialized'):\n            self.initialized = True\n    \n    def _log(self, level, message):\n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        print(f\"[{level}] {message}\")\n    \n    def log_info(self, message):\n        self._log('INFO', message)\n    \n    def log_error(self, message):\n        self._log('ERROR', message)\n    \n    def log_debug(self, message):\n        self._log('DEBUG', message)"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Command Pattern Implementation",
        "description": "Implement the Command pattern to create an undo/redo system for text editing.",
        "starterCode": "from abc import ABC, abstractmethod\n\nclass Command(ABC):\n    @abstractmethod\n    def execute(self):\n        pass\n    \n    @abstractmethod\n    def undo(self):\n        pass\n\nclass TextEditor:\n    def __init__(self):\n        self.content = \"\"\n    \n    def insert_text(self, text, position):\n        # Insert text at position\n        pass\n    \n    def delete_text(self, start, end):\n        # Delete text from start to end\n        pass\n\nclass InsertCommand(Command):\n    # Implement insert command with undo\n    pass\n\nclass CommandManager:\n    # Implement undo/redo functionality\n    pass\n\n# Test\neditor = TextEditor()\nmanager = CommandManager()\ncmd = InsertCommand(editor, \"Hello\", 0)\nmanager.execute_command(cmd)\nprint(editor.content)  # \"Hello\"",
        "expectedOutput": "Hello",
        "solution": "from abc import ABC, abstractmethod\n\nclass Command(ABC):\n    @abstractmethod\n    def execute(self):\n        pass\n    \n    @abstractmethod\n    def undo(self):\n        pass\n\nclass TextEditor:\n    def __init__(self):\n        self.content = \"\"\n    \n    def insert_text(self, text, position):\n        self.content = self.content[:position] + text + self.content[position:]\n    \n    def delete_text(self, start, end):\n        deleted = self.content[start:end]\n        self.content = self.content[:start] + self.content[end:]\n        return deleted\n\nclass InsertCommand(Command):\n    def __init__(self, editor, text, position):\n        self.editor = editor\n        self.text = text\n        self.position = position\n    \n    def execute(self):\n        self.editor.insert_text(self.text, self.position)\n    \n    def undo(self):\n        end_pos = self.position + len(self.text)\n        self.editor.delete_text(self.position, end_pos)\n\nclass CommandManager:\n    def __init__(self):\n        self.history = []\n        self.current_index = -1\n    \n    def execute_command(self, command):\n        command.execute()\n        # Remove any commands after current index (for new branch)\n        self.history = self.history[:self.current_index + 1]\n        self.history.append(command)\n        self.current_index += 1\n    \n    def undo(self):\n        if self.current_index >= 0:\n            self.history[self.current_index].undo()\n            self.current_index -= 1\n    \n    def redo(self):\n        if self.current_index < len(self.history) - 1:\n            self.current_index += 1\n            self.history[self.current_index].execute()"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Observer Pattern with Event System",
        "description": "Implement a comprehensive event system using Observer pattern with event filtering and priority.",
        "starterCode": "from abc import ABC, abstractmethod\nfrom typing import Any, List\nfrom enum import Enum\n\nclass EventType(Enum):\n    USER_LOGIN = \"user_login\"\n    USER_LOGOUT = \"user_logout\"\n    FILE_UPLOAD = \"file_upload\"\n    SYSTEM_ERROR = \"system_error\"\n\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, event_type: EventType, data: Any):\n        pass\n\nclass EventManager:\n    # Implement event system with observer pattern\n    # Support event filtering and observer priority\n    pass\n\nclass EmailNotifier(Observer):\n    # Implement email notifications for specific events\n    pass\n\nclass SecurityLogger(Observer):\n    # Implement security logging\n    pass\n\n# Test\nmanager = EventManager()\nemail_notifier = EmailNotifier()\nsecurity_logger = SecurityLogger()\n\nmanager.subscribe(EventType.USER_LOGIN, email_notifier)\nmanager.subscribe(EventType.SYSTEM_ERROR, security_logger, priority=1)\nmanager.notify(EventType.USER_LOGIN, {\"user\": \"alice\", \"ip\": \"192.168.1.1\"})",
        "expectedOutput": "Email: User alice logged in from 192.168.1.1\nSecurity: Login event logged",
        "solution": "from abc import ABC, abstractmethod\nfrom typing import Any, List, Dict, Optional\nfrom enum import Enum\nfrom dataclasses import dataclass\n\nclass EventType(Enum):\n    USER_LOGIN = \"user_login\"\n    USER_LOGOUT = \"user_logout\"\n    FILE_UPLOAD = \"file_upload\"\n    SYSTEM_ERROR = \"system_error\"\n\nclass Observer(ABC):\n    @abstractmethod\n    def update(self, event_type: EventType, data: Any):\n        pass\n\n@dataclass\nclass ObserverWrapper:\n    observer: Observer\n    priority: int = 0\n    event_filter: Optional[callable] = None\n\nclass EventManager:\n    def __init__(self):\n        self.observers: Dict[EventType, List[ObserverWrapper]] = {}\n    \n    def subscribe(self, event_type: EventType, observer: Observer, \n                 priority: int = 0, event_filter: callable = None):\n        if event_type not in self.observers:\n            self.observers[event_type] = []\n        \n        wrapper = ObserverWrapper(observer, priority, event_filter)\n        self.observers[event_type].append(wrapper)\n        \n        # Sort by priority (higher priority first)\n        self.observers[event_type].sort(key=lambda x: x.priority, reverse=True)\n    \n    def unsubscribe(self, event_type: EventType, observer: Observer):\n        if event_type in self.observers:\n            self.observers[event_type] = [\n                wrapper for wrapper in self.observers[event_type]\n                if wrapper.observer != observer\n            ]\n    \n    def notify(self, event_type: EventType, data: Any):\n        if event_type in self.observers:\n            for wrapper in self.observers[event_type]:\n                # Apply filter if exists\n                if wrapper.event_filter is None or wrapper.event_filter(data):\n                    wrapper.observer.update(event_type, data)\n\nclass EmailNotifier(Observer):\n    def update(self, event_type: EventType, data: Any):\n        if event_type == EventType.USER_LOGIN:\n            user = data.get('user', 'Unknown')\n            ip = data.get('ip', 'Unknown')\n            print(f\"Email: User {user} logged in from {ip}\")\n        elif event_type == EventType.SYSTEM_ERROR:\n            error = data.get('error', 'Unknown error')\n            print(f\"Email: System error occurred - {error}\")\n\nclass SecurityLogger(Observer):\n    def update(self, event_type: EventType, data: Any):\n        if event_type == EventType.USER_LOGIN:\n            print(\"Security: Login event logged\")\n        elif event_type == EventType.SYSTEM_ERROR:\n            severity = data.get('severity', 'low')\n            print(f\"Security: {severity.upper()} severity error logged\")"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "Which pattern ensures only one instance of a class exists?",
        "type": "multiple-choice",
        "options": ["Factory", "Singleton", "Observer", "Strategy"],
        "correctAnswer": 1
      },
      {
        "id": "q2", 
        "question": "The Decorator pattern is used to:",
        "type": "multiple-choice",
        "options": ["Create objects", "Add behavior dynamically", "Handle events", "Manage state"],
        "correctAnswer": 1
      }
    ]
  },
  {
    "id": "data-structures-advanced",
    "title": "Advanced Data Structures",
    "description": "Master trees, graphs, tries, and specialized data structures for competitive programming.",
    "category": "Data Structures",
    "difficulty": "advanced",
    "estimatedTime": 50,
    "xpReward": 230,
    "prerequisites": ["python-dictionaries", "python-lists"],
    "steps": [
      {
        "id": "step-1",
        "type": "content",
        "title": "Tree Data Structures",
        "content": "Trees are hierarchical data structures fundamental to computer science:\n\n**Binary Trees:**\n• Each node has at most 2 children\n• Binary Search Tree (BST): Left < Root < Right\n• AVL Tree: Self-balancing BST\n• Red-Black Tree: Another self-balancing BST\n\n**Specialized Trees:**\n• Heap: Complete binary tree with heap property\n• Trie: Prefix tree for string operations\n• Segment Tree: For range queries\n• Fenwick Tree: For cumulative frequency\n\n**Applications:**\n• Database indexing (B-trees)\n• File systems (directory trees)\n• Expression parsing (AST)\n• Autocomplete (Tries)\n• Priority queues (Heaps)"
      },
      {
        "id": "step-2",
        "type": "code",
        "title": "Binary Search Tree Implementation",
        "content": "Implement a complete Binary Search Tree with all operations:",
        "code": "from typing import Optional, List, Any\nfrom collections import deque\n\nclass TreeNode:\n    \"\"\"Node for Binary Search Tree\"\"\"\n    def __init__(self, val: int):\n        self.val = val\n        self.left: Optional['TreeNode'] = None\n        self.right: Optional['TreeNode'] = None\n        self.height = 1  # For AVL tree operations\n    \n    def __repr__(self):\n        return f\"TreeNode({self.val})\"\n\nclass BinarySearchTree:\n    \"\"\"Complete Binary Search Tree implementation\"\"\"\n    \n    def __init__(self):\n        self.root: Optional[TreeNode] = None\n        self.size = 0\n    \n    def insert(self, val: int) -> None:\n        \"\"\"Insert a value into the BST\"\"\"\n        if self.root is None:\n            self.root = TreeNode(val)\n            self.size = 1\n        else:\n            self._insert_recursive(self.root, val)\n    \n    def _insert_recursive(self, node: TreeNode, val: int) -> TreeNode:\n        \"\"\"Recursive helper for insertion\"\"\"\n        if val < node.val:\n            if node.left is None:\n                node.left = TreeNode(val)\n                self.size += 1\n            else:\n                self._insert_recursive(node.left, val)\n        elif val > node.val:\n            if node.right is None:\n                node.right = TreeNode(val)\n                self.size += 1\n            else:\n                self._insert_recursive(node.right, val)\n        # Duplicate values are ignored\n        return node\n    \n    def search(self, val: int) -> bool:\n        \"\"\"Search for a value in the BST\"\"\"\n        return self._search_recursive(self.root, val)\n    \n    def _search_recursive(self, node: Optional[TreeNode], val: int) -> bool:\n        \"\"\"Recursive helper for search\"\"\"\n        if node is None:\n            return False\n        \n        if val == node.val:\n            return True\n        elif val < node.val:\n            return self._search_recursive(node.left, val)\n        else:\n            return self._search_recursive(node.right, val)\n    \n    def delete(self, val: int) -> None:\n        \"\"\"Delete a value from the BST\"\"\"\n        self.root = self._delete_recursive(self.root, val)\n    \n    def _delete_recursive(self, node: Optional[TreeNode], val: int) -> Optional[TreeNode]:\n        \"\"\"Recursive helper for deletion\"\"\"\n        if node is None:\n            return None\n        \n        if val < node.val:\n            node.left = self._delete_recursive(node.left, val)\n        elif val > node.val:\n            node.right = self._delete_recursive(node.right, val)\n        else:\n            # Node to be deleted found\n            self.size -= 1\n            \n            # Case 1: No children (leaf node)\n            if node.left is None and node.right is None:\n                return None\n            \n            # Case 2: One child\n            if node.left is None:\n                return node.right\n            if node.right is None:\n                return node.left\n            \n            # Case 3: Two children\n            # Find inorder successor (smallest in right subtree)\n            successor = self._find_min(node.right)\n            node.val = successor.val\n            node.right = self._delete_recursive(node.right, successor.val)\n        \n        return node\n    \n    def _find_min(self, node: TreeNode) -> TreeNode:\n        \"\"\"Find minimum value node in subtree\"\"\"\n        while node.left is not None:\n            node = node.left\n        return node\n    \n    def _find_max(self, node: TreeNode) -> TreeNode:\n        \"\"\"Find maximum value node in subtree\"\"\"\n        while node.right is not None:\n            node = node.right\n        return node\n    \n    def inorder(self) -> List[int]:\n        \"\"\"Inorder traversal (sorted order)\"\"\"\n        result = []\n        self._inorder_recursive(self.root, result)\n        return result\n    \n    def _inorder_recursive(self, node: Optional[TreeNode], result: List[int]) -> None:\n        \"\"\"Recursive helper for inorder traversal\"\"\"\n        if node is not None:\n            self._inorder_recursive(node.left, result)\n            result.append(node.val)\n            self._inorder_recursive(node.right, result)\n    \n    def preorder(self) -> List[int]:\n        \"\"\"Preorder traversal\"\"\"\n        result = []\n        self._preorder_recursive(self.root, result)\n        return result\n    \n    def _preorder_recursive(self, node: Optional[TreeNode], result: List[int]) -> None:\n        \"\"\"Recursive helper for preorder traversal\"\"\"\n        if node is not None:\n            result.append(node.val)\n            self._preorder_recursive(node.left, result)\n            self._preorder_recursive(node.right, result)\n    \n    def postorder(self) -> List[int]:\n        \"\"\"Postorder traversal\"\"\"\n        result = []\n        self._postorder_recursive(self.root, result)\n        return result\n    \n    def _postorder_recursive(self, node: Optional[TreeNode], result: List[int]) -> None:\n        \"\"\"Recursive helper for postorder traversal\"\"\"\n        if node is not None:\n            self._postorder_recursive(node.left, result)\n            self._postorder_recursive(node.right, result)\n            result.append(node.val)\n    \n    def level_order(self) -> List[List[int]]:\n        \"\"\"Level-order traversal (BFS)\"\"\"\n        if not self.root:\n            return []\n        \n        result = []\n        queue = deque([self.root])\n        \n        while queue:\n            level_size = len(queue)\n            level_values = []\n            \n            for _ in range(level_size):\n                node = queue.popleft()\n                level_values.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            result.append(level_values)\n        \n        return result\n    \n    def height(self) -> int:\n        \"\"\"Calculate height of the tree\"\"\"\n        return self._height_recursive(self.root)\n    \n    def _height_recursive(self, node: Optional[TreeNode]) -> int:\n        \"\"\"Recursive helper for height calculation\"\"\"\n        if node is None:\n            return 0\n        \n        left_height = self._height_recursive(node.left)\n        right_height = self._height_recursive(node.right)\n        \n        return 1 + max(left_height, right_height)\n    \n    def is_valid_bst(self) -> bool:\n        \"\"\"Validate if tree maintains BST property\"\"\"\n        return self._is_valid_bst_recursive(self.root, float('-inf'), float('inf'))\n    \n    def _is_valid_bst_recursive(self, node: Optional[TreeNode], \n                               min_val: float, max_val: float) -> bool:\n        \"\"\"Recursive helper for BST validation\"\"\"\n        if node is None:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (self._is_valid_bst_recursive(node.left, min_val, node.val) and\n                self._is_valid_bst_recursive(node.right, node.val, max_val))\n    \n    def range_query(self, low: int, high: int) -> List[int]:\n        \"\"\"Find all values in range [low, high]\"\"\"\n        result = []\n        self._range_query_recursive(self.root, low, high, result)\n        return result\n    \n    def _range_query_recursive(self, node: Optional[TreeNode], \n                              low: int, high: int, result: List[int]) -> None:\n        \"\"\"Recursive helper for range queries\"\"\"\n        if node is None:\n            return\n        \n        # If current node is in range, add it\n        if low <= node.val <= high:\n            result.append(node.val)\n        \n        # Recursively search left subtree if needed\n        if node.val > low:\n            self._range_query_recursive(node.left, low, high, result)\n        \n        # Recursively search right subtree if needed\n        if node.val < high:\n            self._range_query_recursive(node.right, low, high, result)\n    \n    def kth_smallest(self, k: int) -> Optional[int]:\n        \"\"\"Find kth smallest element (1-indexed)\"\"\"\n        if k <= 0 or k > self.size:\n            return None\n        \n        return self._kth_smallest_recursive(self.root, k)[1]\n    \n    def _kth_smallest_recursive(self, node: Optional[TreeNode], k: int) -> tuple:\n        \"\"\"Returns (count, kth_value) tuple\"\"\"\n        if node is None:\n            return 0, None\n        \n        # Count nodes in left subtree\n        left_count, left_result = self._kth_smallest_recursive(node.left, k)\n        \n        if left_result is not None:\n            return left_count, left_result\n        \n        # Current node is the kth smallest\n        if left_count + 1 == k:\n            return left_count + 1, node.val\n        \n        # Search in right subtree\n        right_count, right_result = self._kth_smallest_recursive(node.right, k - left_count - 1)\n        \n        return left_count + 1 + right_count, right_result\n    \n    def print_tree(self) -> None:\n        \"\"\"Print tree structure visually\"\"\"\n        if not self.root:\n            print(\"Empty tree\")\n            return\n        \n        self._print_tree_recursive(self.root, \"\", True)\n    \n    def _print_tree_recursive(self, node: Optional[TreeNode], \n                             prefix: str, is_last: bool) -> None:\n        \"\"\"Recursive helper for tree visualization\"\"\"\n        if node is not None:\n            print(prefix + (\"└── \" if is_last else \"├── \") + str(node.val))\n            \n            # Calculate new prefix for children\n            new_prefix = prefix + (\"    \" if is_last else \"│   \")\n            \n            # Print children\n            children = [child for child in [node.left, node.right] if child is not None]\n            \n            for i, child in enumerate(children):\n                is_last_child = (i == len(children) - 1)\n                self._print_tree_recursive(child, new_prefix, is_last_child)\n\ndef demonstrate_bst():\n    \"\"\"Demonstrate BST operations\"\"\"\n    print(\"🌳 Binary Search Tree Operations\")\n    print(\"=\" * 40)\n    \n    # Create BST and insert values\n    bst = BinarySearchTree()\n    values = [50, 30, 70, 20, 40, 60, 80, 10, 25, 35, 45]\n    \n    print(f\"Inserting values: {values}\")\n    for val in values:\n        bst.insert(val)\n    \n    print(f\"\\nTree size: {bst.size}\")\n    print(f\"Tree height: {bst.height()}\")\n    print(f\"Is valid BST: {bst.is_valid_bst()}\")\n    \n    # Print tree structure\n    print(\"\\nTree structure:\")\n    bst.print_tree()\n    \n    # Traversals\n    print(f\"\\nInorder (sorted): {bst.inorder()}\")\n    print(f\"Preorder: {bst.preorder()}\")\n    print(f\"Postorder: {bst.postorder()}\")\n    print(f\"Level order: {bst.level_order()}\")\n    \n    # Search operations\n    search_values = [40, 65, 90]\n    print(f\"\\nSearch results:\")\n    for val in search_values:\n        found = bst.search(val)\n        print(f\"  {val}: {'Found' if found else 'Not found'}\")\n    \n    # Range queries\n    print(f\"\\nRange queries:\")\n    ranges = [(25, 45), (15, 35), (60, 85)]\n    for low, high in ranges:\n        result = bst.range_query(low, high)\n        print(f\"  Range [{low}, {high}]: {result}\")\n    \n    # Kth smallest\n    print(f\"\\nKth smallest elements:\")\n    for k in [1, 3, 5, 7, 11]:\n        kth = bst.kth_smallest(k)\n        print(f\"  {k}th smallest: {kth}\")\n    \n    # Deletions\n    print(f\"\\nDeletions:\")\n    delete_values = [20, 30, 50]  # Leaf, one child, two children\n    \n    for val in delete_values:\n        print(f\"\\nDeleting {val}:\")\n        bst.delete(val)\n        print(f\"  Inorder after deletion: {bst.inorder()}\")\n        print(f\"  Tree size: {bst.size}\")\n        print(f\"  Is valid BST: {bst.is_valid_bst()}\")\n\n# Run demonstration\ndemonstrate_bst()",
        "language": "python"
      }
    ],
    "practiceProblems": [
      {
        "id": "easy-1",
        "difficulty": "Easy",
        "title": "Binary Tree Level Order Traversal",
        "description": "Given a binary tree, return the level order traversal of its nodes' values.",
        "starterCode": "from collections import deque\n\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef level_order(root):\n    # Return level order traversal as list of lists\n    # Each sublist contains nodes at the same level\n    pass\n\n# Test\nroot = TreeNode(3)\nroot.left = TreeNode(9)\nroot.right = TreeNode(20)\nroot.right.left = TreeNode(15)\nroot.right.right = TreeNode(7)\nprint(level_order(root))  # [[3], [9, 20], [15, 7]]",
        "expectedOutput": "[[3], [9, 20], [15, 7]]",
        "solution": "from collections import deque\n\ndef level_order(root):\n    if not root:\n        return []\n    \n    result = []\n    queue = deque([root])\n    \n    while queue:\n        level_size = len(queue)\n        level_nodes = []\n        \n        for _ in range(level_size):\n            node = queue.popleft()\n            level_nodes.append(node.val)\n            \n            if node.left:\n                queue.append(node.left)\n            if node.right:\n                queue.append(node.right)\n        \n        result.append(level_nodes)\n    \n    return result"
      },
      {
        "id": "medium-1",
        "difficulty": "Medium",
        "title": "Validate Binary Search Tree",
        "description": "Determine if a given binary tree is a valid binary search tree.",
        "starterCode": "def is_valid_bst(root):\n    # Return True if tree is valid BST, False otherwise\n    # Use inorder traversal or range validation\n    pass\n\n# Test\nroot = TreeNode(2)\nroot.left = TreeNode(1)\nroot.right = TreeNode(3)\nprint(is_valid_bst(root))  # True\n\ninvalid_root = TreeNode(5)\ninvalid_root.left = TreeNode(1)\ninvalid_root.right = TreeNode(4)\ninvalid_root.right.left = TreeNode(3)\ninvalid_root.right.right = TreeNode(6)\nprint(is_valid_bst(invalid_root))  # False",
        "expectedOutput": "True\nFalse",
        "solution": "def is_valid_bst(root):\n    def validate(node, min_val, max_val):\n        if not node:\n            return True\n        \n        if node.val <= min_val or node.val >= max_val:\n            return False\n        \n        return (validate(node.left, min_val, node.val) and\n                validate(node.right, node.val, max_val))\n    \n    return validate(root, float('-inf'), float('inf'))"
      },
      {
        "id": "hard-1",
        "difficulty": "Hard",
        "title": "Serialize and Deserialize Binary Tree",
        "description": "Design an algorithm to serialize and deserialize a binary tree.",
        "starterCode": "class Codec:\n    def serialize(self, root):\n        # Encode tree to a single string\n        pass\n    \n    def deserialize(self, data):\n        # Decode string to tree\n        pass\n\n# Test\ncodec = Codec()\nroot = TreeNode(1)\nroot.left = TreeNode(2)\nroot.right = TreeNode(3)\nroot.right.left = TreeNode(4)\nroot.right.right = TreeNode(5)\n\nserialized = codec.serialize(root)\nprint(f\"Serialized: {serialized}\")\ndeserialized = codec.deserialize(serialized)\n# Should reconstruct the same tree",
        "expectedOutput": "Serialized: 1,2,null,null,3,4,null,null,5,null,null",
        "solution": "class Codec:\n    def serialize(self, root):\n        def preorder(node):\n            if not node:\n                return 'null'\n            return str(node.val) + ',' + preorder(node.left) + ',' + preorder(node.right)\n        \n        return preorder(root)\n    \n    def deserialize(self, data):\n        def build_tree():\n            val = next(values)\n            if val == 'null':\n                return None\n            \n            node = TreeNode(int(val))\n            node.left = build_tree()\n            node.right = build_tree()\n            return node\n        \n        values = iter(data.split(','))\n        return build_tree()"
      }
    ],
    "quiz": [
      {
        "id": "q1",
        "question": "What is the time complexity of search in a balanced BST?",
        "type": "multiple-choice",
        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
        "correctAnswer": 1
      },
      {
        "id": "q2",
        "question": "Which traversal of BST gives sorted order?",
        "type": "multiple-choice",
        "options": ["Preorder", "Inorder", "Postorder", "Level order"],
        "correctAnswer": 1
      }
    ]
  }
]